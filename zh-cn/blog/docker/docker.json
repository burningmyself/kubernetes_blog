{
  "filename": "docker.md",
  "__html": "<h1>Docker</h1>\n<h2>Docker简介</h2>\n<ul>\n<li>Docker是开源应用容器引擎，轻量级容器技术。</li>\n<li>基于Go语言，并遵循Apache2.0协议开源</li>\n<li>Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux系统上，也可以实现虚拟化</li>\n<li>容器完全使用沙箱技术，相互之间不会有任何接口</li>\n<li>类似于虚拟机技术(vmware、vitural)，但docker直接运行在操作系统(Linux)上，而不是运行在虚拟机中，速度快，性能开销极低</li>\n</ul>\n<p>白话文，简介就是:</p>\n<blockquote>\n<p>Docker支持将软件编译成一个镜像，然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像。\n运行中的这个镜像称为容器，容器启动是非常快速的。类似windows里面的ghost操 作系统，安装好后什么都有了。</p>\n</blockquote>\n<h2>什么是Docker</h2>\n<p>Docker 是一个开源的应用容器引擎，基于Go语言，诞生于2013年初，最初发起者是dotCloud公司，开发者可以打包应用到一个轻量级、可移植的容器中，然后发布到主流Linux系统上运行。\n为什么用Docker</p>\n<ul>\n<li>持续交付和部署：使用Docker可以通过定制应用镜像来实现持续集成，持续交付，部署。开发人员构建后的镜像，结合持续集成系统进行集成测试，而运维人员则可以在生产环境中快速部署该镜像，也可以结合持续部署系统进行自动部署。</li>\n<li>更高效的资源利用：Docker是基于内核级的虚拟化，可以实现更高效的性能，同时对资源的额外需求很低，相比传统虚拟机方式，相同配置的主机能够运行更多的应用。\n更轻松的迁移和扩展：Docker容器几乎可以在任何平台上运行，同时支持主流的操作系统发行版本。</li>\n<li>更快速的启动时间：传统的虚拟机技术启动应用服务往往需要数分钟，而Docker容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到妙级，甚至毫秒级的启动时间，大大的节约了开发，测试，部署的时间。\nDocker与传统虚拟机差异</li>\n</ul>\n<p>传统虚拟化方式</p>\n<p><img src=\"./../img/docker1.png\" alt=\"传统虚拟化方式\" title=\"传统虚拟化方式\">\nDocker虚拟化方式</p>\n<p><img src=\"./../img/docker2.png\" alt=\"Docker虚拟化方式\" title=\"Docker虚拟化方式\"></p>\n<p>传统虚拟化是在硬件层面实现虚拟化，需要有额外的虚拟机管理应用和虚拟机操作系统层，而Docker容器是在操作系统层面实现虚拟化，直接复用本地主机操作系统，更加轻量级。</p>\n<h2>核心概念</h2>\n<ul>\n<li>Docker镜像：类似于虚拟机里的镜像，是一个只读的模板，一个独立的文件系统，使用镜像可以创建容器，可以理解为镜像是容器的基石。</li>\n<li>Docker容器：是由Docker镜像创建的运行实例，类似于轻量级的沙箱，每个容器之间都是相互隔离的。支持的操作有启动，停止，删除等。</li>\n<li>docker客户端(Client)：客户端通过命令行或其他工具使用Docker API(<a href=\"https://docs.docker.com/reference/api/docker_remote_api\">https://docs.docker.com/reference/api/docker_remote_api</a>)与Docker的守护进程进行通信</li>\n<li>docker主机(Host)：一个物理或虚拟的机器用来执行Docker守护进程和容器</li>\n<li>docker仓库(Registry)：Docker仓库用来存储镜像，可以理解为代码控制中的代码仓库，Docker Hub(<a href=\"https://hub.docker.com\">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用</li>\n</ul>\n<h2>Docker安装及启停</h2>\n<ol>\n<li>查看centos版本</li>\n</ol>\n<pre><code class=\"language-cmd\">Docker 要求 CentOS 系统的内核版本高于 <span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">10</span>\n通过命令：uname -r\n查看当前centos版本，如版本不符，需升级系统版本\n</code></pre>\n<ol start=\"2\">\n<li>升级软件包及内核(可选)</li>\n</ol>\n<pre><code class=\"language-s\">yum update\n</code></pre>\n<ol start=\"3\">\n<li>安装docker</li>\n</ol>\n<pre><code class=\"language-s\">yum install docker\n</code></pre>\n<ol start=\"4\">\n<li>启动docker</li>\n</ol>\n<pre><code class=\"language-s\">systemctl start docker\n</code></pre>\n<ol start=\"5\">\n<li>将docker服务设为开机启动</li>\n</ol>\n<pre><code class=\"language-s\">systemtctl enable docker\n</code></pre>\n<ol start=\"6\">\n<li>停止docker</li>\n</ol>\n<pre><code class=\"language-s\">systemtctl stop docker\n</code></pre>\n<h2>Docker常用命令及操作</h2>\n<p>docker镜像命令</p>\n<pre><code class=\"language-s\">docker search mysql  ## 搜索镜像\ndocker pull mysql ## 下载镜像 下载命名为：docker pull 镜像名:tag，其中tag多为系统的版本，可选的，默认为least\ndocker images ## 镜像列表 RESPOSITORY为镜像名 TAG为镜像版本，least代表最新 IMAGE_ID 为该镜像唯一ID CREATED 为该镜像创建时间 SIZE 为该镜像大小\ndocker rmi image-id ##删除指定镜像\ndocker rmi $(docker images -q) ##删除所有镜像\ndocker run --name container-name -d image-name ##根据镜像启动容器 -- name：为容器起一个名称\n-d：detached，执行完这句命令后，控制台将不会阻塞，可以继续输入命令操作\nimage-name：要运行的镜像名称\ndocker ps ##查看运行中容器  CONTAINER ID：启动时生成的ID\nIMAGE：该容器使用的镜像\nCOMMAND：容器启动时执行的命令\nCREATED：容器创建时间\nSTATUS：当前容器状态\nPORTS：当前容器所使用的默认端口号\nNAMES：启动时给容器设置的名称\ndocker stop container-name/container-id ## 停止运行中容器\ndocker ps -a ##查看所有的容器\ndocker start container-name/container-id ##启动容器\ndocker rm container-id ## 删除单个容器\ndocker rm $(docker ps -a -q ) ## 删除所有容器\ndocker run --name tomcat2 -d -p 8888:8080 tomcat ## 启动做端口映射的容器\ndocker logs container-id/container-name ##查看容器日志\ndocker port container-id ## 查看端口映射\ndocker exec -it container-id/container-name bash  ##容器登录命令为\nexit ##容器退出命令\n</code></pre>\n<p><a href=\"https://docs.docker.com/engine/reference/commandline/docker/\" title=\"更多命令可以参考\">更多命令可以参考</a></p>\n<h2>镜像操作指令</h2>\n<ul>\n<li>获取镜像：\ndocker pull centos    (默认获取centos最新的镜像)\ndocker pull centos:7 (获取指定标签镜像)</li>\n<li>查看本地镜像：\ndocker images</li>\n<li>查看镜像详细信息：\ndocker inspect centos:7</li>\n<li>查看镜像历史：\ndocker history centos:7</li>\n<li>删除镜像：\nA:使用标签删除：docker rmi centos\nB:使用ID删除：docker rimi</li>\n<li>构建镜像：\nA:使用docker commit命令\nB:使用Dockerfile构建</li>\n</ul>\n<h2>使用docker commit</h2>\n<p>例：构建一个带有jdk的镜像</p>\n<p>按照如下步骤操作</p>\n<pre><code class=\"language-s\">[root@localhost ~]# docker run -it centos:7 /bin/bash\n[root@060793baf536 /]# yum install wget\n[root@060793baf536 /]# wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.rpm\n\n[root@060793baf536 /]# rpm -ivh jdk-8u131-linux-x64.rpm\nPreparing...                          ################################# [100%]\nUpdating / installing...\n   1:jdk1.8.0_131-2000:1.8.0_131-fcs  ################################# [100%]\nUnpacking JAR files...\n        tools.jar...\n        plugin.jar...\n        javaws.jar...\n        deploy.jar...\n        rt.jar...\n        jsse.jar...\n        charsets.jar...\n        localedata.jar...\n[root@060793baf536 /]# exit\n[root@localhost ~]# docker commit 060793baf536 centos/jdk:2.0\n</code></pre>\n<p>通过docker images命令可以看到新增了centos/jdk 标签为2.0的镜像</p>\n<h2>使用Dockerfile构建</h2>\n<p>实际使用中不推荐使用docker commit构建，应使用更灵活和强大的Dockerfile构建docker镜像，直接举例来认识Dockerfile。</p>\n<p>例：构建一个带有jdk的centos7镜像</p>\n<pre><code class=\"language-s\">[root@localhost Dockerfile]# mkdir Dockerfile\n[root@localhost Dockerfile]# cd Dockerfile\n编写Dockerfile：\nFROM centos:7\nMAINTAINER  Java-Road &quot;Java-Road@qq.com&quot;\n\nRUN mkdir /usr/local/jdk\nCOPY jdk-8u171-linux-x64.rpm /usr/local/jdk/\nRUN rpm -ivh /usr/local/jdk/jdk-8u171-linux-x64.rpm\n执行如下指令：\n[root@localhost Dockerfile]# docker build -t centos/jdk .\n</code></pre>\n<p>运行结果如下：\n<img src=\"./../img/docker3.png\" alt=\"运行结果如下：\" title=\"运行结果如下：\">\ndocker images可以看到新生成的centos/jdk镜像</p>\n<h2>容器操作指令</h2>\n<ul>\n<li>创建启动容器：</li>\n</ul>\n<pre><code class=\"language-s\">[root@localhost ~]# docker run centos:7 /bin/echo'hello world'\n        容器运行完后直接退出\n</code></pre>\n<ul>\n<li>交互形式创建启动容器</li>\n</ul>\n<pre><code class=\"language-s\">[root@localhost ~]# docker run -it centos:7 /bin/bash\n[root@802e3623e566 /]# ps\n   PID TTY          TIME CMD\n     1 ?        00:00:00 bash\n    13 ?        00:00:00 ps\n[root@802e3623e566 /]# exit\n执行exit才能退出容器\n</code></pre>\n<ul>\n<li>守护状态运行容器</li>\n</ul>\n<pre><code class=\"language-s\">[root@localhost ~]# docker run -d centos:7 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;\n</code></pre>\n<ul>\n<li>启动已有的容器：</li>\n</ul>\n<pre><code class=\"language-s\">* docker start 容器ID\n# 例：\n[root@localhost ~]# docker start 802e3623e566\n</code></pre>\n<ul>\n<li>停止运行的容器</li>\n</ul>\n<pre><code class=\"language-s\">* docker stop 容器ID\n# 例：\n[root@localhost ~]# docker stop 802e3623e566\n</code></pre>\n<ul>\n<li>删除容器：</li>\n</ul>\n<pre><code class=\"language-s\">[root@localhost ~]# docker stop 89566e38c7fb\n[root@localhost ~]# docker rm 89566e38c7fb\n</code></pre>\n<ul>\n<li>进入运行的容器：</li>\n</ul>\n<pre><code class=\"language-s\">[root@localhost ~]# docker exec -it cbd8b1f35dcc /bin/bash\n</code></pre>\n<ul>\n<li>导出容器：</li>\n</ul>\n<pre><code class=\"language-s\"># 导出容器cbd8b1f35dcc到centos_test.tar文件\n[root@localhost ~]# docker export -o centos_test.tar cbd8b1f35dcc\n# 导出的tar文件可以在其他机器上，通过导入来重新运行\n</code></pre>\n<ul>\n<li>导入容器：</li>\n</ul>\n<pre><code class=\"language-s\"># 把导出的文件centos_test.tar通过docker import导入变成镜像\n[root@localhost ~]# docker import centos_test.tar test/centos\n# 通过docker images命令可以看到增加了个test/centos镜像\n</code></pre>\n<h2>实例：制作自己的 Docker 容器</h2>\n<blockquote>\n<p>下面我以 <a href=\"http://www.ruanyifeng.com/blog/2017/08/koa.html\">koa-demos</a>项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。\n作为准备工作，请先下载源码。</p>\n</blockquote>\n<pre><code class=\"language-s\">$ git clone https://github.com/ruanyf/koa-demos.git\n$ cd koa-demos\n</code></pre>\n<h2>Dockerfile 文件</h2>\n<p>首先，在项目的根目录下，新建一个文本文件.dockerignore，写入下面的内容。</p>\n<pre><code class=\"language-s\">.git\nnode_modules\nnpm-debug.log\n</code></pre>\n<p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p>\n<p>然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的内容。</p>\n<pre><code class=\"language-s\">FROM node:8.4\nCOPY . /app\nWORKDIR /app\nRUN npm install --registry=https://registry.npm.taobao.org\nEXPOSE 3000\n</code></pre>\n<p>上面代码一共五行，含义如下。</p>\n<ul>\n<li>FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。</li>\n<li>COPY . /app：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。</li>\n<li>WORKDIR /app：指定接下来的工作路径为/app。</li>\n<li>RUN npm install：在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li>\n<li>EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li>\n</ul>\n<h2>创建 image 文件</h2>\n<p>有了 Dockerfile 文件以后，就可以使用docker image build命令创建 image 文件了。</p>\n<pre><code class=\"language-s\">$ docker image build -t koa-demo .\n# 或者\n$ docker image build -t koa-demo:0.0.1 .\n``` s\n上面代码中，-t参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是latest。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。\n\n如果运行成功，就可以看到新生成的 image 文件koa-demo了。\n``` s\n$ docker image ls\n</code></pre>\n<h2>生成容器</h2>\n<pre><code class=\"language-s\">docker container run命令会从 image 文件生成容器。\n$ docker container run -p 8000:3000 -it koa-demo /bin/bash\n# 或者\n$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash\n</code></pre>\n<p>上面命令的各个参数含义如下：</p>\n<ul>\n<li>-p参数：容器的 3000 端口映射到本机的 8000 端口。</li>\n<li>-it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li>\n<li>koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li>\n<li>/bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li>\n</ul>\n<p>如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。</p>\n<pre><code class=\"language-s\">root@66d80f4aaf1e:/app#\n</code></pre>\n<p>这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。</p>\n<pre><code class=\"language-s\">root@66d80f4aaf1e:/app# node demos/01.js\n</code></pre>\n<p>这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 <a href=\"http://127.0.0.1:8000\">http://127.0.0.1:8000</a>，网页显示&quot;Not Found&quot;，这是因为这个 demo 没有写路由。</p>\n<p>这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。</p>\n<p>现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用docker container kill终止容器运行。</p>\n<pre><code class=\"language-s\"># 在本机的另一个终端窗口，查出容器的 ID\n$ docker container ls\n\n# 停止指定的容器运行\n$ docker container kill [containerID]\n\n# 容器停止运行之后，并不会消失，用下面的命令删除容器文件。\n\n# 查出容器的 ID\n$ docker container ls --all\n\n# 删除指定的容器文件\n$ docker container rm [containerID]\n\n#也可以使用docker container run命令的--rm参数，在容器终止运行后自动删除容器文件。\n$ docker container run --rm -p 8000:3000 -it koa-demo /bin/bash\n</code></pre>\n<h2>CMD 命令</h2>\n<p>上一节的例子里面，容器启动以后，需要手动输入命令node demos/01.js。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。</p>\n<pre><code class=\"language-s\">FROM node:8.4\nCOPY . /app\nWORKDIR /app\nRUN npm install --registry=https://registry.npm.taobao.org\nEXPOSE 3000\nCMD node demos/01.js\n</code></pre>\n<p>上面的 Dockerfile 里面，多了最后一行CMD node demos/01.js，它表示容器启动后自动执行node demos/01.js。</p>\n<p>你可能会问，RUN命令与CMD命令的区别在哪里？简单说，RUN命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个RUN命令，但是只能有一个CMD命令。</p>\n<p>注意，指定了CMD命令以后，docker container run命令就不能附加命令了（比如前面的/bin/bash），否则它会覆盖CMD命令。现在，启动容器可以使用下面的命令。</p>\n<pre><code class=\"language-s\">$ docker container run --rm -p 8000:3000 -it koa-demo:0.0.1\n</code></pre>\n<h2>发布 image 文件</h2>\n<p>容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。\n首先，去 <a href=\"http://hub.docker.com\">hub.docker.com</a> 或 <a href=\"http://cloud.docker.com\">cloud.docker.com</a> 注册一个账户。然后，用下面的命令登录。</p>\n<pre><code class=\"language-s\">$ docker login\n# 接着，为本地的 image 标注用户名和版本。\n$ docker image tag [imageName] [username]/[repository]:[tag]\n# 实例\n$ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1\n#也可以不标注用户名，重新构建一下 image 文件。\n$ docker image build -t [username]/[repository]:[tag] .\n# 最后，发布 image 文件。\n$ docker image push [username]/[repository]:[tag]\n</code></pre>\n<p>发布成功以后，登录 <a href=\"http://hub.docker.com\">hub.docker.com</a>，就可以看到已经发布的 image 文件。</p>\n<h2>其他有用的命令</h2>\n<p>docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。</p>\n<ol>\n<li>docker container start</li>\n</ol>\n<p>前面的docker container run命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用docker container start命令，它用来启动已经生成、已经停止运行的容器文件。</p>\n<pre><code class=\"language-s\">$ docker container start [containerID]\n</code></pre>\n<ol start=\"2\">\n<li>docker container stop</li>\n</ol>\n<p>前面的docker container kill命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而docker container stop命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</p>\n<pre><code class=\"language-s\">$ bash container stop [containerID]\n</code></pre>\n<p>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p>\n<ol start=\"3\">\n<li>docker container logs</li>\n</ol>\n<p>docker container logs命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令查看输出。</p>\n<pre><code class=\"language-s\">$ docker container logs [containerID]\n</code></pre>\n<ol start=\"4\">\n<li>docker container exec</li>\n</ol>\n<p>docker container exec命令用于进入一个正在运行的 docker 容器。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。</p>\n<pre><code class=\"language-s\">$ docker container exec -it [containerID] /bin/bash\n</code></pre>\n<ol start=\"5\">\n<li>docker container cp</li>\n</ol>\n<p>docker container cp命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。</p>\n<pre><code class=\"language-s\">$ docker container cp [containID]:[/path/to/file] .\n</code></pre>\n",
  "link": "\\zh-cn\\blog\\docker\\docker.html",
  "meta": {}
}