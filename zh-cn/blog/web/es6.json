{
  "filename": "es6.md",
  "__html": "<h1>JavaScript ES6 规范</h1>\n<h2>ES6 简介</h2>\n<p>ECMAScript 6 简称 ES6，是 JavaScript 语言的下一代标准，已经在2015年6月正式发布了。它的目标是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>\n<p>ECMAScript 和 JavaScript 的关系：前者是后者的语法规格，后者是前者的一种实现</p>\n<p><a href=\"http://babeljs.io/\">Babel</a>：将ES6代码转为ES5代码</p>\n<h2>新特性</h2>\n<h3>let、const</h3>\n<p>let 定义的变量不会被变量提升，const 定义的常量不能被修改，let 和 const 都是块级作用域</p>\n<p>ES6前，js 是没有块级作用域 {} 的概念的。（有函数作用域、全局作用域、eval作用域）</p>\n<p>ES6后，let 和 const 的出现，js 也有了块级作用域的概念，前端的知识是日新月异的~</p>\n<p>变量提升：在ES6以前，var关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部；不在函数内即在全局作用域的最顶部。这样就会引起一些误解。例如：</p>\n<pre><code class=\"language-js\">console.log(a); // undefined\nvar a = 'hello';\n \n# 上面的代码相当于\nvar a;\nconsole.log(a);\na = 'hello';\n \n# 而 let 就不会被变量提升\nconsole.log(a); // a is not defined\nlet a = 'hello';\n</code></pre>\n<p>const 定义的常量不能被修改</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"bai\"</span>;\nname = <span class=\"hljs-string\">\"ming\"</span>;\n<span class=\"hljs-built_in\">console</span>.log(name); <span class=\"hljs-comment\">// ming</span>\n<span class=\"hljs-keyword\">const</span> name = <span class=\"hljs-string\">\"bai\"</span>;\nname = <span class=\"hljs-string\">\"ming\"</span>; <span class=\"hljs-comment\">// Assignment to constant variable.</span>\n<span class=\"hljs-built_in\">console</span>.log(name);\n</code></pre>\n<h3>import、export</h3>\n<p>import导入模块、export导出模块</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// 全部导入</span>\n<span class=\"hljs-keyword\">import</span> people <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./example'</span>\n \n<span class=\"hljs-comment\">// 将整个模块当作单一对象进行导入，该模块的所有导出都会作为对象的属性存在</span>\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> example <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./example.js\"</span>\n<span class=\"hljs-built_in\">console</span>.log(example.name)\n<span class=\"hljs-built_in\">console</span>.log(example.getName())\n \n<span class=\"hljs-comment\">// 导入部分，引入非 default 时，使用花括号</span>\n<span class=\"hljs-keyword\">import</span> {name, age} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./example'</span>\n \n \n<span class=\"hljs-comment\">// 导出默认, 有且只有一个默认</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> App\n \n<span class=\"hljs-comment\">// 部分导出</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">App</span> <span class=\"hljs-title\">extend</span> <span class=\"hljs-title\">Component</span> </span>{};\n</code></pre>\n<h3>class、extends、super</h3>\n<p>ES5中最令人头疼的的几个部分：原型、构造函数，继承，有了ES6我们不再烦恼！</p>\n<p>ES6引入了Class（类）这个概念。</p>\n<pre><code class=\"language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span> </span>{\n<span class=\"hljs-keyword\">constructor</span>() {\n<span class=\"hljs-keyword\">this</span>.type = <span class=\"hljs-string\">'animal'</span>;\n}\nsays(say) {\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.type + <span class=\"hljs-string\">' says '</span> + say);\n}\n}\n \n<span class=\"hljs-keyword\">let</span> animal = <span class=\"hljs-keyword\">new</span> Animal();\nanimal.says(<span class=\"hljs-string\">'hello'</span>); <span class=\"hljs-comment\">//animal says hello</span>\n \n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Cat</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Animal</span> </span>{\n<span class=\"hljs-keyword\">constructor</span>() {\n<span class=\"hljs-keyword\">super</span>();\n<span class=\"hljs-keyword\">this</span>.type = <span class=\"hljs-string\">'cat'</span>;\n}\n}\n \n<span class=\"hljs-keyword\">let</span> cat = <span class=\"hljs-keyword\">new</span> Cat();\ncat.says(<span class=\"hljs-string\">'hello'</span>); <span class=\"hljs-comment\">//cat says hello</span>\n</code></pre>\n<p>上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实力对象可以共享的。</p>\n<p>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个Cat类，该类通过extends关键字，继承了Animal类的所有属性和方法。</p>\n<p>super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p>\n<p>ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// ES5</span>\n<span class=\"hljs-keyword\">var</span> Shape = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">id, x, y</span>) </span>{\n<span class=\"hljs-keyword\">this</span>.id = id,\n<span class=\"hljs-keyword\">this</span>.move(x, y);\n};\nShape.prototype.move = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">x, y</span>) </span>{\n<span class=\"hljs-keyword\">this</span>.x = x;\n<span class=\"hljs-keyword\">this</span>.y = y;\n};\n \n<span class=\"hljs-keyword\">var</span> Rectangle = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">id</span>(<span class=\"hljs-params\">ix, x, y, width, height</span>) </span>{\nShape.call(<span class=\"hljs-keyword\">this</span>, id, x, y);\n<span class=\"hljs-keyword\">this</span>.width = width;\n<span class=\"hljs-keyword\">this</span>.height = height;\n};\nRectangle.prototype = <span class=\"hljs-built_in\">Object</span>.create(Shape.prototype);\nRectangle.prototype.constructor = Rectangle;\n \n<span class=\"hljs-keyword\">var</span> Circle = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">id, x, y, radius</span>) </span>{\nShape.call(<span class=\"hljs-keyword\">this</span>, id, x, y);\n<span class=\"hljs-keyword\">this</span>.radius = radius;\n};\nCircle.prototype = <span class=\"hljs-built_in\">Object</span>.create(Shape.prototype);\nCircle.prototype.constructor = Circle;\n \n<span class=\"hljs-comment\">// ES6</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Shape</span> </span>{\n<span class=\"hljs-keyword\">constructor</span>(id, x, y) {\n<span class=\"hljs-keyword\">this</span>.id = id <span class=\"hljs-keyword\">this</span>.move(x, y);\n}\nmove(x, y) {\n<span class=\"hljs-keyword\">this</span>.x = x <span class=\"hljs-keyword\">this</span>.y = y;\n}\n}\n \n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Rectangle</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Shape</span> </span>{\n<span class=\"hljs-keyword\">constructor</span>(id, x, y, width, height) {\n<span class=\"hljs-keyword\">super</span>(id, x, y) <span class=\"hljs-keyword\">this</span>.width = width <span class=\"hljs-keyword\">this</span>.height = height;\n}\n}\n \n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Circle</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Shape</span> </span>{\n<span class=\"hljs-keyword\">constructor</span>(id, x, y, radius) {\n<span class=\"hljs-keyword\">super</span>(id, x, y) <span class=\"hljs-keyword\">this</span>.radius = radius;\n}\n}\n</code></pre>\n<h3>arrow functions （箭头函数）</h3>\n<p>函数的快捷写法。不需要 function 关键字来创建函数，省略 return 关键字，继承当前上下文的 this 关键字</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// ES5</span>\n<span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">var</span> newArr1 = arr1.map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">x</span>) </span>{\n<span class=\"hljs-keyword\">return</span> x + <span class=\"hljs-number\">1</span>;\n});\n \n<span class=\"hljs-comment\">// ES6</span>\n<span class=\"hljs-keyword\">let</span> arr2 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">let</span> newArr2 = arr2.map(<span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =&gt;</span> {\nx + <span class=\"hljs-number\">1</span>\n});\n</code></pre>\n<p>箭头函数小细节：当你的函数有且仅有一个参数的时候，是可以省略掉括号的；当你函数中有且仅有一个表达式的时候可以省略{}</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">let</span> arr2 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">let</span> newArr2 = arr2.map(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x + <span class=\"hljs-number\">1</span>);\n</code></pre>\n<p>JavaScript语言的this对象一直是一个令人头痛的问题，运行上面的代码会报错，这是因为setTimeout中的this指向的是全局对象。</p>\n<pre><code class=\"language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span> </span>{\n<span class=\"hljs-keyword\">constructor</span>() {\n<span class=\"hljs-keyword\">this</span>.type = <span class=\"hljs-string\">'animal'</span>;\n}\nsays(say) {\nsetTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.type + <span class=\"hljs-string\">' says '</span> + say);\n}, <span class=\"hljs-number\">1000</span>);\n}\n}\n<span class=\"hljs-keyword\">var</span> animal = <span class=\"hljs-keyword\">new</span> Animal();\nanimal.says(<span class=\"hljs-string\">'hi'</span>); <span class=\"hljs-comment\">//undefined says hi</span>\n</code></pre>\n<p>解决办法：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// 传统方法1: 将this传给self,再用self来指代this</span>\nsays(say) {\n<span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>;\nsetTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n<span class=\"hljs-built_in\">console</span>.log(self.type + <span class=\"hljs-string\">' says '</span> + say);\n}, <span class=\"hljs-number\">1000</span>);\n}\n \n<span class=\"hljs-comment\">// 传统方法2: 用bind(this),即</span>\nsays(say) {\nsetTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.type + <span class=\"hljs-string\">' says '</span> + say);\n}.bind(<span class=\"hljs-keyword\">this</span>), <span class=\"hljs-number\">1000</span>);\n}\n \n<span class=\"hljs-comment\">// ES6: 箭头函数</span>\n<span class=\"hljs-comment\">// 当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象</span>\nsays(say) {\nsetTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.type + <span class=\"hljs-string\">' says '</span> + say);\n}, <span class=\"hljs-number\">1000</span>);\n}\n</code></pre>\n<h3>template string （模板字符串）</h3>\n<p>解决了 ES5 在字符串功能上的痛点。</p>\n<p>第一个用途：字符串拼接。将表达式嵌入字符串中进行拼接，用 <code>和${}</code>来界定。</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// es5</span>\n<span class=\"hljs-keyword\">var</span> name1 = <span class=\"hljs-string\">\"bai\"</span>;\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'hello'</span> + name1);\n \n<span class=\"hljs-comment\">// es6</span>\n<span class=\"hljs-keyword\">const</span> name2 = <span class=\"hljs-string\">\"ming\"</span>;\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`hello<span class=\"hljs-subst\">${name2}</span>`</span>);\n</code></pre>\n<p>第二个用途：在ES5时我们通过反斜杠来做多行字符串拼接。ES6反引号 `` 直接搞定。</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// es5</span>\n<span class=\"hljs-keyword\">var</span> msg = <span class=\"hljs-string\">\"Hi \\\nman!\"</span>;\n \n<span class=\"hljs-comment\">// es6</span>\n<span class=\"hljs-keyword\">const</span> template = <span class=\"hljs-string\">`&lt;div&gt;\n&lt;span&gt;hello world&lt;/span&gt;\n&lt;/div&gt;`</span>;\n</code></pre>\n<p>另外：includes repeat</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// includes：判断是否包含然后直接返回布尔值</span>\n<span class=\"hljs-keyword\">let</span> str = <span class=\"hljs-string\">'hahah'</span>;\n<span class=\"hljs-built_in\">console</span>.log(str.includes(<span class=\"hljs-string\">'y'</span>)); <span class=\"hljs-comment\">// false</span>\n \n<span class=\"hljs-comment\">// repeat: 获取字符串重复n次</span>\n<span class=\"hljs-keyword\">let</span> s = <span class=\"hljs-string\">'he'</span>;\n<span class=\"hljs-built_in\">console</span>.log(s.repeat(<span class=\"hljs-number\">3</span>)); <span class=\"hljs-comment\">// 'hehehe'</span>\n</code></pre>\n<h3>destructuring （解构）</h3>\n<p>简化数组和对象中信息的提取。</p>\n<p>ES6前，我们一个一个获取对象信息；</p>\n<p>ES6后，解构能让我们从对象或者数组里取出数据存为变量</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// ES5</span>\n<span class=\"hljs-keyword\">var</span> people1 = {\n<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'bai'</span>,\n<span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span>,\n<span class=\"hljs-attr\">color</span>: [<span class=\"hljs-string\">'red'</span>, <span class=\"hljs-string\">'blue'</span>]\n};\n \n<span class=\"hljs-keyword\">var</span> myName = people1.name;\n<span class=\"hljs-keyword\">var</span> myAge = people1.age;\n<span class=\"hljs-keyword\">var</span> myColor = people1.color[<span class=\"hljs-number\">0</span>];\n<span class=\"hljs-built_in\">console</span>.log(myName + <span class=\"hljs-string\">'----'</span> + myAge + <span class=\"hljs-string\">'----'</span> + myColor);\n \n<span class=\"hljs-comment\">// ES6</span>\n<span class=\"hljs-keyword\">let</span> people2 = {\n<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'ming'</span>,\n<span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span>,\n<span class=\"hljs-attr\">color</span>: [<span class=\"hljs-string\">'red'</span>, <span class=\"hljs-string\">'blue'</span>]\n}\n \n<span class=\"hljs-keyword\">let</span> { name, age } = people2;\n<span class=\"hljs-keyword\">let</span> [first, second] = people2.color;\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${name}</span>----<span class=\"hljs-subst\">${age}</span>----<span class=\"hljs-subst\">${first}</span>`</span>);\n</code></pre>\n<h3>default 函数默认参数</h3>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// ES5 给函数定义参数默认值</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">num</span>) </span>{\nnum = num || <span class=\"hljs-number\">200</span>;\n<span class=\"hljs-keyword\">return</span> num;\n}\n \n<span class=\"hljs-comment\">// ES6</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">num = <span class=\"hljs-number\">200</span></span>) </span>{\n<span class=\"hljs-keyword\">return</span> num;\n}\n</code></pre>\n<h3>rest arguments （rest参数）</h3>\n<p>解决了 es5 复杂的 arguments 问题</p>\n<pre><code class=\"language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">x, y, ...rest</span>) </span>{\n<span class=\"hljs-keyword\">return</span> ((x + y) * rest.length);\n}\nfoo(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">'hello'</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-number\">7</span>); <span class=\"hljs-comment\">// 9</span>\n</code></pre>\n<h3>Spread Operator （展开运算符）</h3>\n<p>第一个用途：组装数组</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">let</span> color = [<span class=\"hljs-string\">'red'</span>, <span class=\"hljs-string\">'yellow'</span>];\n<span class=\"hljs-keyword\">let</span> colorful = [...color, <span class=\"hljs-string\">'green'</span>, <span class=\"hljs-string\">'blue'</span>];\n<span class=\"hljs-built_in\">console</span>.log(colorful); <span class=\"hljs-comment\">// [\"red\", \"yellow\", \"green\", \"blue\"]</span>\n</code></pre>\n<p>第二个用途：获取数组除了某几项的其他项</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">let</span> num = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">9</span>];\n<span class=\"hljs-keyword\">let</span> [first, second, ...rest] = num;\n<span class=\"hljs-built_in\">console</span>.log(rest); <span class=\"hljs-comment\">// [5, 7, 9]</span>\n</code></pre>\n<h3>对象</h3>\n<p>对象初始化简写</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// ES5</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">people</span>(<span class=\"hljs-params\">name, age</span>) </span>{\n<span class=\"hljs-keyword\">return</span> {\n<span class=\"hljs-attr\">name</span>: name,\n<span class=\"hljs-attr\">age</span>: age\n};\n}\n \n<span class=\"hljs-comment\">// ES6</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">people</span>(<span class=\"hljs-params\">name, age</span>) </span>{\n<span class=\"hljs-keyword\">return</span> {\nname,\nage\n};\n}\n</code></pre>\n<p>对象字面量简写（省略冒号与 function 关键字）</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// ES5</span>\n<span class=\"hljs-keyword\">var</span> people1 = {\n<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'bai'</span>,\n<span class=\"hljs-attr\">getName</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.name);\n}\n};\n \n<span class=\"hljs-comment\">// ES6</span>\n<span class=\"hljs-keyword\">let</span> people2 = {\n<span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'bai'</span>,\ngetName () {\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.name);\n}\n};\n</code></pre>\n<p>另外：Object.assign()</p>\n<p>ES6 对象提供了Object.assign()这个方法来实现浅复制。Object.assign()可以把任意多个源对象自身可枚举的属性拷贝给目标对象，然后返回目标对象。第一参数即为目标对象。在实际项目中，我们为了不改变源对象。一般会把目标对象传为{}</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> obj = <span class=\"hljs-built_in\">Object</span>.assign({}, objA, objB)\n \n<span class=\"hljs-comment\">// 给对象添加属性</span>\n<span class=\"hljs-keyword\">this</span>.seller = <span class=\"hljs-built_in\">Object</span>.assign({}, <span class=\"hljs-keyword\">this</span>.seller, response.data)\n</code></pre>\n<h3>Promise</h3>\n<p>用同步的方式去写异步代码</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// 发起异步请求</span>\nfetch(<span class=\"hljs-string\">'/api/todos'</span>)\n.then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> res.json())\n.then(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> ({\ndata\n}))\n.catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> ({\nerr\n}));\n</code></pre>\n<h3>Generators</h3>\n<p>生成器（ generator）是能返回一个迭代器的函数。</p>\n<p>生成器函数也是一种函数，最直观的表现就是比普通的function多了个星号*，在其函数体内可以使用yield关键字,有意思的是函数会在每个yield后暂停。</p>\n<p>这里生活中有一个比较形象的例子。咱们到银行办理业务时候都得向大厅的机器取一张排队号。你拿到你的排队号，机器并不会自动为你再出下一张票。也就是说取票机“暂停”住了，直到下一个人再次唤起才会继续吐票。</p>\n<p>迭代器：当你调用一个generator时，它将返回一个迭代器对象。这个迭代器对象拥有一个叫做next的方法来帮助你重启generator函数并得到下一个值。next方法不仅返回值，它返回的对象具有两个属性：done和value。value是你获得的值，done用来表明你的generator是否已经停止提供值。继续用刚刚取票的例子，每张排队号就是这里的value，打印票的纸是否用完就这是这里的done。</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// 生成器</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">createIterator</span>(<span class=\"hljs-params\"></span>) </span>{\n<span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;\n<span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;\n}\n \n<span class=\"hljs-comment\">// 生成器能像正规函数那样被调用，但会返回一个迭代器</span>\n<span class=\"hljs-keyword\">let</span> iterator = createIterator();\n \n<span class=\"hljs-built_in\">console</span>.log(iterator.next().value); <span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-built_in\">console</span>.log(iterator.next().value); <span class=\"hljs-comment\">// 2</span>\n<span class=\"hljs-built_in\">console</span>.log(iterator.next().value); <span class=\"hljs-comment\">// 3</span>\n</code></pre>\n<p>迭代器对异步编程作用很大，异步调用对于我们来说是很困难的事，我们的函数并不会等待异步调用完再执行，你可能会想到用回调函数，（当然还有其他方案比如Promise比如Async/await）。</p>\n<p>生成器可以让我们的代码进行等待。就不用嵌套的回调函数。使用generator可以确保当异步调用在我们的generator函数运行一下行代码之前完成时暂停函数的执行。</p>\n<p>那么问题来了，咱们也不能手动一直调用next()方法，你需要一个能够调用生成器并启动迭代器的方法。就像这样子的：</p>\n<pre><code class=\"language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">run</span>(<span class=\"hljs-params\">taskDef</span>) </span>{\n<span class=\"hljs-comment\">// taskDef 即一个生成器函数</span>\n<span class=\"hljs-comment\">// 创建迭代器，让它在别处可用</span>\n<span class=\"hljs-keyword\">let</span> task = taskDef();\n \n<span class=\"hljs-comment\">// 启动任务</span>\n<span class=\"hljs-keyword\">let</span> result = task.next();\n \n<span class=\"hljs-comment\">// 递归使用函数来保持对 next() 的调用</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">step</span>(<span class=\"hljs-params\"></span>) </span>{\n<span class=\"hljs-comment\">// 如果还有更多要做的</span>\n<span class=\"hljs-keyword\">if</span> (!result.done) {\nresult = task.next();\nstep();\n}\n}\n \n<span class=\"hljs-comment\">// 开始处理过程</span>\nstep();\n}\n</code></pre>\n<h2>总结</h2>\n<p>以上就是 ES6 最常用的一些语法，可以说这20%的语法，在ES6的日常使用中占了80%</p>\n<p><a href=\"http://es6.ruanyifeng.com/\">更多ES6语法点击这里</a></p>\n",
  "link": "\\zh-cn\\blog\\web\\es6.html",
  "meta": {}
}