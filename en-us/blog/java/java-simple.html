<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="java-simple" />
	<meta name="description" content="java-simple" />
	<!-- 网页标签标题 -->
	<title>java-simple</title>
	<link rel="shortcut icon" href="/img/docsite.ico"/>
	<link rel="stylesheet" href="/build/blogDetail.css" />
</head>
<body>
	<div id="root"><div class="blog-detail-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/en-us/index.html"><img class="logo" src="/img/dubbo_colorful.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">中</span><div class="header-menu"><img class="header-menu-toggle" src="/img/system/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/en-us/index.html" target="_self">HOME</a></li><li class="menu-item menu-item-normal"><a href="/en-us/docs/introduction.html" target="_self">DOCS</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/en-us/blog/index.html" target="_self">BLOG</a></li><li class="menu-item menu-item-normal"><a href="/en-us/community/index.html" target="_self">COMMUNITY</a></li></ul></div></div></header><section class="blog-content markdown-body"><h1>Java 代码精简</h1>
<h2>利用语法</h2>
<h3>利用三元表达式</h3>
<p>普通</p>
<pre><code class="language-java">String title;
<span class="hljs-keyword">if</span> (isMember(phone)) {
    title = <span class="hljs-string">"会员"</span>;
} <span class="hljs-keyword">else</span> {
    title = <span class="hljs-string">"游客"</span>;
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">String title = isMember(phone) ? <span class="hljs-string">"会员"</span> : <span class="hljs-string">"游客"</span>;
</code></pre>
<blockquote>
<p>注意：对于包装类型的算术计算，需要注意避免拆包时的空指针问题。</p>
</blockquote>
<h3>利用 for-each 语句</h3>
<blockquote>
<p>从 Java 5 起，提供了 for-each 循环，简化了数组和集合的循环遍历。for-each  循环允许你无需保持传统 for 循环中的索引就可以遍历数组，或在使用迭代器时无需在 while 循环中调用 hasNext 方法和 next 方法就可以遍历集合。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java">
<span class="hljs-keyword">double</span>[] values = ...;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; values.length; i++) {
    <span class="hljs-keyword">double</span> value = values[i];
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 处理value</span>
}

List&lt;Double&gt; valueList = ...;
Iterator&lt;Double&gt; iterator = valueList.iterator();
<span class="hljs-keyword">while</span> (iterator.hasNext()) {
    Double value = iterator.next();
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 处理value</span>
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">
<span class="hljs-keyword">double</span>[] values = ...;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">double</span> value : values) {
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 处理value</span>
}

List&lt;Double&gt; valueList = ...;
<span class="hljs-keyword">for</span>(Double value : valueList) {
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 处理value</span>
}

</code></pre>
<h3>利用 try-with-resource 语句</h3>
<blockquote>
<p>所有实现 Closeable 接口的“资源”，均可采用 try-with-resource 进行简化。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java">BufferedReader reader = <span class="hljs-keyword">null</span>;
<span class="hljs-keyword">try</span> {
    reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">"cities.csv"</span>));
    String line;
    <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 处理line</span>
    }
} <span class="hljs-keyword">catch</span> (IOException e) {
    log.error(<span class="hljs-string">"读取文件异常"</span>, e);
} <span class="hljs-keyword">finally</span> {
    <span class="hljs-keyword">if</span> (reader != <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">try</span> {
            reader.close();
        } <span class="hljs-keyword">catch</span> (IOException e) {
            log.error(<span class="hljs-string">"关闭文件异常"</span>, e);
        }
    }
}
</code></pre>
<p>精简</p>
<pre><code class="language-java"><span class="hljs-keyword">try</span> (BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">"test.txt"</span>))) {
    String line;
    <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 处理line</span>
    }
} <span class="hljs-keyword">catch</span> (IOException e) {
    log.error(<span class="hljs-string">"读取文件异常"</span>, e);
}
</code></pre>
<h3>利用 return 关键字</h3>
<blockquote>
<p>利用 return 关键字，可以提前函数返回，避免定义中间变量。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java">
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasSuper</span><span class="hljs-params">(@NonNull List&lt;UserDO&gt; userList)</span> </span>{
    <span class="hljs-keyword">boolean</span> hasSuper = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">for</span> (UserDO user : userList) {
        <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(user.getIsSuper())) {
            hasSuper = <span class="hljs-keyword">true</span>;
            <span class="hljs-keyword">break</span>;
        }
    }
    <span class="hljs-keyword">return</span> hasSuper;
}
</code></pre>
<p>精简</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasSuper</span><span class="hljs-params">(@NonNull List&lt;UserDO&gt; userList)</span> </span>{
    <span class="hljs-keyword">for</span> (UserDO user : userList) {
        <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(user.getIsSuper())) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
}
</code></pre>
<h3>利用 static 关键字</h3>
<blockquote>
<p>利用 static 关键字，可以把字段变成静态字段，也可以把函数变为静态函数，调用时就无需初始化类对象。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java">
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GisHelper</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-keyword">double</span> lng1, <span class="hljs-keyword">double</span> lat1, <span class="hljs-keyword">double</span> lng2, <span class="hljs-keyword">double</span> lat2)</span> </span>{
        <span class="hljs-comment">// 方法实现代码</span>
    }
}


GisHelper gisHelper = <span class="hljs-keyword">new</span> GisHelper();
<span class="hljs-keyword">double</span> distance = gisHelper.distance(<span class="hljs-number">116.178692</span>D, <span class="hljs-number">39.967115</span>D, <span class="hljs-number">116.410778</span>D, <span class="hljs-number">39.899721</span>D);

</code></pre>
<p>精简</p>
<pre><code class="language-java">
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GisHelper</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-keyword">double</span> lng1, <span class="hljs-keyword">double</span> lat1, <span class="hljs-keyword">double</span> lng2, <span class="hljs-keyword">double</span> lat2)</span> </span>{
        <span class="hljs-comment">// 方法实现代码</span>
    }
}

<span class="hljs-keyword">double</span> distance = GisHelper.distance(<span class="hljs-number">116.178692</span>D, <span class="hljs-number">39.967115</span>D, <span class="hljs-number">116.410778</span>D, <span class="hljs-number">39.899721</span>D);

</code></pre>
<h3>利用 lambda 表达式</h3>
<blockquote>
<p>Java 8 发布以后，lambda 表达式大量替代匿名内部类的使用，在简化了代码的同时，更突出了原有匿名内部类中真正有用的那部分代码。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java">
<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() {
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 线程处理代码</span>
    }
}).start();
</code></pre>
<p>精简</p>
<pre><code class="language-java"><span class="hljs-keyword">new</span> Thread(() -&gt; {
    <span class="hljs-comment">// 线程处理代码</span>
}).start();
</code></pre>
<h3>利用方法引用</h3>
<blockquote>
<p>方法引用（::），可以简化 lambda 表达式，省略变量声明和函数调用。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java">Arrays.sort(nameArray, (a, b) -&gt; a.compareToIgnoreCase(b));
List&lt;Long&gt; userIdList = userList.stream()
    .map(user -&gt; user.getId())
    .collect(Collectors.toList());
</code></pre>
<p>精简</p>
<pre><code class="language-java">
Arrays.sort(nameArray, String::compareToIgnoreCase);
List&lt;Long&gt; userIdList = userList.stream()
    .map(UserDO::getId)
    .collect(Collectors.toList());
</code></pre>
<h3>利用静态导入</h3>
<blockquote>
<p>静态导入（import static），当程序中大量使用同一静态常量和函数时，可以简化静态常量和函数的引用。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java">
List&lt;Double&gt; areaList = radiusList.stream().map(r -&gt; Math.PI * Math.pow(r, <span class="hljs-number">2</span>)).collect(Collectors.toList());

</code></pre>
<p>精简</p>
<pre><code class="language-java">
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.PI;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.pow;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.stream.Collectors.toList;

List&lt;Double&gt; areaList = radiusList.stream().map(r -&gt; PI * pow(r, <span class="hljs-number">2</span>)).collect(toList());

</code></pre>
<ul>
<li>注意：静态引入容易造成代码阅读困难，所以在实际项目中应该警慎使用。</li>
</ul>
<h3>利用 unchecked 异常</h3>
<blockquote>
<p>Java 的异常分为两类：Checked 异常和 Unchecked 异常。Unchecked 异常继承了RuntimeException ，特点是代码不需要处理它们也能通过编译，所以它们称作  Unchecked 异常。利用 Unchecked 异常，可以避免不必要的 try-catch 和 throws 异常处理。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java">
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createUser</span><span class="hljs-params">(UserCreateVO create, OpUserVO user)</span> <span class="hljs-keyword">throws</span> BusinessException </span>{
        checkOperatorUser(user);
        ...
    }
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkOperatorUser</span><span class="hljs-params">(OpUserVO user)</span> <span class="hljs-keyword">throws</span> BusinessException </span>{
        <span class="hljs-keyword">if</span> (!hasPermission(user)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BusinessException(<span class="hljs-string">"用户无操作权限"</span>);
        }
        ...
    }
    ...
}

<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>{
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserService userService;

    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/createUser"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;Void&gt; <span class="hljs-title">createUser</span><span class="hljs-params">(@RequestBody @Valid UserCreateVO create, OpUserVO user)</span> <span class="hljs-keyword">throws</span> BusinessException </span>{
        userService.createUser(create, user);
        <span class="hljs-keyword">return</span> Result.success();
    }
    ...
}
</code></pre>
<p>精简</p>
<pre><code class="language-java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createUser</span><span class="hljs-params">(UserCreateVO create, OpUserVO user)</span> </span>{
        checkOperatorUser(user);
        ...
    }
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkOperatorUser</span><span class="hljs-params">(OpUserVO user)</span> </span>{
        <span class="hljs-keyword">if</span> (!hasPermission(user)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BusinessRuntimeException(<span class="hljs-string">"用户无操作权限"</span>);
        }
        ...
    }
    ...
}

<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>{
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserService userService;

    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/createUser"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;Void&gt; <span class="hljs-title">createUser</span><span class="hljs-params">(@RequestBody @Valid UserCreateVO create, OpUserVO user)</span> </span>{
        userService.createUser(create, user);
        <span class="hljs-keyword">return</span> Result.success();
    }
    ...
}
</code></pre>
<h2>利用注解</h2>
<h3>利用 Lombok 注解</h3>
<blockquote>
<p>Lombok 提供了一组有用的注解，可以用来消除Java类中的大量样板代码。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserVO</span> </span>{
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.id;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Long id)</span> </span>{
        <span class="hljs-keyword">this</span>.id = id;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
    }
    ...
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">
<span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserVO</span> </span>{
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-keyword">private</span> String name;
    ...
}
</code></pre>
<h3>利用 Validation 注解</h3>
<p>普通</p>
<pre><code class="language-java"><span class="hljs-meta">@Data</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserCreateVO</span> </span>{    
  <span class="hljs-keyword">private</span> String name;    
  <span class="hljs-keyword">private</span> Long companyId;
}

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>{    
  <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">createUser</span><span class="hljs-params">(UserCreateVO create)</span> </span>{        
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 创建用户 </span>
    <span class="hljs-keyword">if</span>(create.getName()==<span class="hljs-keyword">null</span>){
      ...
    }  

    <span class="hljs-keyword">if</span>(create.getCompanyId()==<span class="hljs-keyword">null</span>){
      ...
    } 

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    
  }
}
</code></pre>
<p>精简</p>
<pre><code class="language-java"><span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserCreateVO</span> </span>{
    <span class="hljs-meta">@NotBlank</span>(message = <span class="hljs-string">"用户名称不能为空"</span>)
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-meta">@NotNull</span>(message = <span class="hljs-string">"公司标识不能为空"</span>)
    <span class="hljs-keyword">private</span> Long companyId;
    ...
}

<span class="hljs-meta">@Service</span>
<span class="hljs-meta">@Validated</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">createUser</span><span class="hljs-params">(@Valid UserCreateVO create)</span> </span>{
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 创建用户</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
}

</code></pre>
<h3>利用 @NonNull 注解</h3>
<blockquote>
<p>Spring 的 @NonNull 注解，用于标注参数或返回值非空，适用于项目内部团队协作。只要实现方和调用方遵循规范，可以避免不必要的空值判断，这充分体现了阿里的“新六脉神剑”提倡的“因为信任，所以简单”。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserVO&gt; <span class="hljs-title">queryCompanyUser</span><span class="hljs-params">(Long companyId)</span> </span>{
    <span class="hljs-comment">// 检查公司标识</span>
    <span class="hljs-keyword">if</span> (companyId == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-comment">// 查询返回用户</span>
    List&lt;UserDO&gt; userList = userDAO.queryByCompanyId(companyId);
    <span class="hljs-keyword">return</span> userList.stream().map(<span class="hljs-keyword">this</span>::transUser).collect(Collectors.toList());
}

Long companyId = <span class="hljs-number">1L</span>;
List&lt;UserVO&gt; userList = queryCompanyUser(companyId);
<span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(userList)) {
    <span class="hljs-keyword">for</span> (UserVO user : userList) {
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 处理公司用户</span>
    }
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">
<span class="hljs-keyword">public</span> <span class="hljs-meta">@NonNull</span> <span class="hljs-function">List&lt;UserVO&gt; <span class="hljs-title">queryCompanyUser</span><span class="hljs-params">(@NonNull Long companyId)</span> </span>{
    List&lt;UserDO&gt; userList = userDAO.queryByCompanyId(companyId);
    <span class="hljs-keyword">return</span> userList.stream().map(<span class="hljs-keyword">this</span>::transUser).collect(Collectors.toList());
}

Long companyId = <span class="hljs-number">1L</span>;
List&lt;UserVO&gt; userList = queryCompanyUser(companyId);
<span class="hljs-keyword">for</span> (UserVO user : userList) {
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 处理公司用户</span>
}
</code></pre>
<h3>利用注解特性</h3>
<p>注解有以下特性可用于精简注解声明：
1、当注解属性值跟默认值一致时，可以删除该属性赋值；
2、当注解只有value属性时，可以去掉value进行简写；
3、当注解属性组合等于另一个特定注解时，直接采用该特定注解。</p>
<p>普通</p>
<pre><code class="language-java"><span class="hljs-meta">@Lazy</span>(<span class="hljs-keyword">true</span>);
<span class="hljs-meta">@Service</span>(value = <span class="hljs-string">"userService"</span>)
<span class="hljs-meta">@RequestMapping</span>(path = <span class="hljs-string">"/getUser"</span>, method = RequestMethod.GET)
</code></pre>
<p>精简</p>
<pre><code class="language-java">
<span class="hljs-meta">@Lazy</span>
<span class="hljs-meta">@Service</span>(<span class="hljs-string">"userService"</span>)
<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/getUser"</span>)
</code></pre>
<h2>利用泛型</h2>
<h3>泛型接口</h3>
<blockquote>
<p>在 Java 没有引入泛型前，都是采用 Object 表示通用对象，最大的问题就是类型无法强校验并且需要强制类型转换。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java">
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object other)</span></span>;
}

<span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserVO</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span> </span>{
    <span class="hljs-keyword">private</span> Long id;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object other)</span> </span>{
        UserVO user = (UserVO)other;
        <span class="hljs-keyword">return</span> Long.compare(<span class="hljs-keyword">this</span>.id, user.id);
    }
}
</code></pre>
<p>精简</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(T other)</span></span>;
}

<span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserVO</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">UserVO</span>&gt; </span>{
    <span class="hljs-keyword">private</span> Long id;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(UserVO other)</span> </span>{
        <span class="hljs-keyword">return</span> Long.compare(<span class="hljs-keyword">this</span>.id, other.id);
    }
}
</code></pre>
<h3>泛型类</h3>
<p>普通</p>
<pre><code class="language-java">
<span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntPoint</span> </span>{
    <span class="hljs-keyword">private</span> Integer x;
    <span class="hljs-keyword">private</span> Integer y;
}

<span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoublePoint</span> </span>{
    <span class="hljs-keyword">private</span> Double x;
    <span class="hljs-keyword">private</span> Double y;
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">
<span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span>&gt; </span>{
    <span class="hljs-keyword">private</span> T x;
    <span class="hljs-keyword">private</span> T y;
}
</code></pre>
<h3>泛型方法</h3>
<p>普通</p>
<pre><code class="language-java">
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, Integer&gt; <span class="hljs-title">newHashMap</span><span class="hljs-params">(String[] keys, Integer[] values)</span> </span>{
    <span class="hljs-comment">// 检查参数非空</span>
    <span class="hljs-keyword">if</span> (ArrayUtils.isEmpty(keys) || ArrayUtils.isEmpty(values)) {
        <span class="hljs-keyword">return</span> Collections.emptyMap();
    }

    <span class="hljs-comment">// 转化哈希映射</span>
    Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    <span class="hljs-keyword">int</span> length = Math.min(keys.length, values.length);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
        map.put(keys[i], values[i]);
    }
    <span class="hljs-keyword">return</span> map;
}

</code></pre>
<p>精简</p>
<pre><code class="language-java">
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;K, V&gt; <span class="hljs-function">Map&lt;K, V&gt; <span class="hljs-title">newHashMap</span><span class="hljs-params">(K[] keys, V[] values)</span> </span>{
    <span class="hljs-comment">// 检查参数非空</span>
    <span class="hljs-keyword">if</span> (ArrayUtils.isEmpty(keys) || ArrayUtils.isEmpty(values)) {
        <span class="hljs-keyword">return</span> Collections.emptyMap();
    }

    <span class="hljs-comment">// 转化哈希映射</span>
    Map&lt;K, V&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    <span class="hljs-keyword">int</span> length = Math.min(keys.length, values.length);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
        map.put(keys[i], values[i]);
    }
    <span class="hljs-keyword">return</span> map;
}
</code></pre>
<h2>利用自身方法</h2>
<h3>利用构造方法</h3>
<blockquote>
<p>构造方法，可以简化对象的初始化和设置属性操作。对于属性字段较少的类，可以自定义构造方法。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java"><span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageDataVO</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
    <span class="hljs-keyword">private</span> Long totalCount;
    <span class="hljs-keyword">private</span> List&lt;T&gt; dataList;
}

PageDataVO&lt;UserVO&gt; pageData = <span class="hljs-keyword">new</span> PageDataVO&lt;&gt;();
pageData.setTotalCount(totalCount);
pageData.setDataList(userList);
<span class="hljs-keyword">return</span> pageData;
</code></pre>
<p>精简</p>
<pre><code class="language-java"><span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageDataVO</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
    <span class="hljs-keyword">private</span> Long totalCount;
    <span class="hljs-keyword">private</span> List&lt;T&gt; dataList;
}

<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PageDataVO&lt;&gt;(totalCount, userList);
</code></pre>
<ul>
<li>注意：如果属性字段被替换时，存在构造函数初始化赋值问题。比如把属性字段title替换为 nickname ，由于构造函数的参数个数和类型不变，原有构造函数初始化语句不会报错，导致把原title值赋值给 nickname 。如果采用 Setter 方法赋值，编译器会提示错误并要求修复。</li>
</ul>
<h3>利用 Set 的 add 方法</h3>
<blockquote>
<p>利用 Set 的 add 方法的返回值，可以直接知道该值是否已经存在，可以避免调用 contains 方法判断存在。</p>
</blockquote>
<p>普通</p>
<p>以下案例是进行用户去重转化操作，需要先调用 contains 方法判断存在，后调用add方法进行添加。</p>
<pre><code class="language-java">
Set&lt;Long&gt; userIdSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
List&lt;UserVO&gt; userVOList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
<span class="hljs-keyword">for</span> (UserDO userDO : userDOList) {
    <span class="hljs-keyword">if</span> (!userIdSet.contains(userDO.getId())) {
        userIdSet.add(userDO.getId());
        userVOList.add(transUser(userDO));
    }
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">
SSet&lt;Long&gt; userIdSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
List&lt;UserVO&gt; userVOList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
<span class="hljs-keyword">for</span> (UserDO userDO : userDOList) {
    <span class="hljs-keyword">if</span> (userIdSet.add(userDO.getId())) {
        userVOList.add(transUser(userDO));
    }
}
</code></pre>
<h3>利用 Map 的 computeIfAbsent 方法</h3>
<blockquote>
<p>利用 Map 的 computeIfAbsent 方法，可以保证获取到的对象非空，从而避免了不必要的空判断和重新设置值。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java">Map&lt;Long, List&lt;UserDO&gt;&gt; roleUserMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
<span class="hljs-keyword">for</span> (UserDO userDO : userDOList) {
    Long roleId = userDO.getRoleId();
    List&lt;UserDO&gt; userList = roleUserMap.get(roleId);
    <span class="hljs-keyword">if</span> (Objects.isNull(userList)) {
        userList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        roleUserMap.put(roleId, userList);
    }
    userList.add(userDO);
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">Map&lt;Long, List&lt;UserDO&gt;&gt; roleUserMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
<span class="hljs-keyword">for</span> (UserDO userDO : userDOList) {
    roleUserMap.computeIfAbsent(userDO.getRoleId(), key -&gt; <span class="hljs-keyword">new</span> ArrayList&lt;&gt;())
        .add(userDO);
}
</code></pre>
<h3>利用链式编程</h3>
<blockquote>
<p>链式编程，也叫级联式编程，调用对象的函数时返回一个this对象指向对象本身，达到链式效果，可以级联调用。链式编程的优点是：编程性强、可读性强、代码简洁。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java">StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-number">96</span>);
builder.append(<span class="hljs-string">"select id, name from "</span>);
builder.append(T_USER);
builder.append(<span class="hljs-string">" where id = "</span>);
builder.append(userId);
builder.append(<span class="hljs-string">";"</span>);
</code></pre>
<p>精简</p>
<pre><code class="language-java">StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-number">96</span>);
builder.append(<span class="hljs-string">"select id, name from "</span>)
    .append(T_USER)
    .append(<span class="hljs-string">" where id = "</span>)
    .append(userId)
    .append(<span class="hljs-string">";"</span>);
</code></pre>
<h2>利用工具方法</h2>
<h3>避免空值判断</h3>
<p>普通</p>
<pre><code class="language-java"><span class="hljs-keyword">if</span> (userList != <span class="hljs-keyword">null</span> &amp;&amp; !userList.isEmpty()) {
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 处理代码</span>
}

</code></pre>
<p>精简</p>
<pre><code class="language-java"><span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(userList)) {
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 处理代码</span>
}
</code></pre>
<h3>避免条件判断</h3>
<p>普通</p>
<pre><code class="language-java"><span class="hljs-keyword">double</span> result;
<span class="hljs-keyword">if</span> (value &lt;= MIN_LIMIT) {
    result = MIN_LIMIT;
} <span class="hljs-keyword">else</span> {
    result = value;
}
</code></pre>
<p>精简</p>
<pre><code class="language-java"><span class="hljs-keyword">double</span> result = Math.max(MIN_LIMIT, value);
</code></pre>
<h3>简化赋值语句</h3>
<p>普通</p>
<pre><code class="language-java">
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;String&gt; ANIMAL_LIST;
<span class="hljs-keyword">static</span> {
    List&lt;String&gt; animalList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    animalList.add(<span class="hljs-string">"dog"</span>);
    animalList.add(<span class="hljs-string">"cat"</span>);
    animalList.add(<span class="hljs-string">"tiger"</span>);
    ANIMAL_LIST = Collections.unmodifiableList(animalList);
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">
<span class="hljs-comment">// JDK流派</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;String&gt; ANIMAL_LIST = Arrays.asList(<span class="hljs-string">"dog"</span>, <span class="hljs-string">"cat"</span>, <span class="hljs-string">"tiger"</span>);
<span class="hljs-comment">// Guava流派</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;String&gt; ANIMAL_LIST = ImmutableList.of(<span class="hljs-string">"dog"</span>, <span class="hljs-string">"cat"</span>, <span class="hljs-string">"tiger"</span>);
</code></pre>
<ul>
<li>注意：Arrays.asList 返回的 List 并不是 ArrayList ，不支持 add 等变更操作。</li>
</ul>
<h3>简化数据拷贝</h3>
<p>普通</p>
<pre><code class="language-java">UserVO userVO = <span class="hljs-keyword">new</span> UserVO();
userVO.setId(userDO.getId());
userVO.setName(userDO.getName());
...
userVO.setDescription(userDO.getDescription());
userVOList.add(userVO);
</code></pre>
<p>精简</p>
<pre><code class="language-java">
UserVO userVO = <span class="hljs-keyword">new</span> UserVO();
BeanUtils.copyProperties(userDO, userVO);
userVOList.add(userVO);

</code></pre>
<p>反例</p>
<pre><code class="language-java">List&lt;UserVO&gt; userVOList = JSON.parseArray(JSON.toJSONString(userDOList), UserVO.class);
</code></pre>
<ul>
<li>精简代码，但不能以过大的性能损失为代价。例子是浅层拷贝，用不着 JSON 这样重量级的武器。</li>
</ul>
<h3>简化异常断言</h3>
<p>普通</p>
<pre><code class="language-java"><span class="hljs-keyword">if</span> (Objects.isNull(userId)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"用户标识不能为空"</span>);
}

</code></pre>
<p>精简</p>
<pre><code class="language-java">Assert.notNull(userId, <span class="hljs-string">"用户标识不能为空"</span>);
</code></pre>
<ul>
<li>注意：可能有些插件不认同这种判断，导致使用该对象时会有空指针警告。</li>
</ul>
<h3>简化测试用例</h3>
<blockquote>
<p>把测试用例数据以 JSON 格式存入文件中，通过 JSON 的 parseObject 和 parseArray 方法解析成对象。虽然执行效率上有所下降，但可以减少大量的赋值语句，从而精简了测试代码。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCreateUser</span><span class="hljs-params">()</span> </span>{
    UserCreateVO userCreate = <span class="hljs-keyword">new</span> UserCreateVO();
    userCreate.setName(<span class="hljs-string">"Changyi"</span>);
    userCreate.setTitle(<span class="hljs-string">"Developer"</span>);
    userCreate.setCompany(<span class="hljs-string">"AMAP"</span>);
    ...
    Long userId  = userService.createUser(OPERATOR, userCreate);
    Assert.assertNotNull(userId, <span class="hljs-string">"创建用户失败"</span>);
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">
<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCreateUser</span><span class="hljs-params">()</span> </span>{
    String jsonText = ResourceHelper.getResourceAsString(getClass(), <span class="hljs-string">"createUser.json"</span>);
    UserCreateVO userCreate = JSON.parseObject(jsonText, UserCreateVO.class);
    Long userId  = userService.createUser(OPERATOR, userCreate);
    Assert.assertNotNull(userId, <span class="hljs-string">"创建用户失败"</span>);
}
</code></pre>
<ul>
<li>建议：JSON 文件名最好以被测试的方法命名，如果有多个版本可以用数字后缀表示。</li>
</ul>
<h3>简化算法实现</h3>
<blockquote>
<p>一些常规算法，已有现成的工具方法，我们就没有必要自己实现了。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java">
<span class="hljs-keyword">int</span> totalSize = valueList.size();
List&lt;List&lt;Integer&gt;&gt; partitionList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; totalSize; i += PARTITION_SIZE) {
    partitionList.add(valueList.subList(i, Math.min(i + PARTITION_SIZE, totalSize)));
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">
List&lt;List&lt;Integer&gt;&gt; partitionList = ListUtils.partition(valueList, PARTITION_SIZE);
</code></pre>
<h3>封装工具方法</h3>
<blockquote>
<p>一些特殊算法，没有现成的工具方法，我们就只好自己亲自实现了。</p>
</blockquote>
<p>普通</p>
<p>比如，SQL 设置参数值的方法就比较难用，setLong 方法不能设置参数值为 null 。</p>
<pre><code class="language-java"> <span class="hljs-comment">// 设置参数值</span>
<span class="hljs-keyword">if</span> (Objects.nonNull(user.getId())) {
  statement.setLong(<span class="hljs-number">1</span>, user.getId());
} <span class="hljs-keyword">else</span> {
    statement.setNull(<span class="hljs-number">1</span>, Types.BIGINT);
}

</code></pre>
<p>精简
我们可以封装为一个工具类 SqlHelper ，简化设置参数值的代码。</p>
<pre><code class="language-java"><span class="hljs-comment">/** SQL辅助类 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlHelper</span> </span>{
    <span class="hljs-comment">/** 设置长整数值 */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLong</span><span class="hljs-params">(PreparedStatement statement, <span class="hljs-keyword">int</span> index, Long value)</span> <span class="hljs-keyword">throws</span> SQLException </span>{
        <span class="hljs-keyword">if</span> (Objects.nonNull(value)) {
            statement.setLong(index, value.longValue());
        } <span class="hljs-keyword">else</span> {
            statement.setNull(index, Types.BIGINT);
        }
    }
    ...
}

 <span class="hljs-comment">// 设置参数值</span>
SqlHelper.setLong(statement, <span class="hljs-number">1</span>, user.getId());
</code></pre>
<h2>利用数据结构</h2>
<h3>利用数组简化</h3>
<blockquote>
<p>对于固定上下限范围的 if-else 语句，可以用数组+循环来简化。
普通</p>
</blockquote>
<pre><code class="language-java">
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getGrade</span><span class="hljs-params">(<span class="hljs-keyword">double</span> score)</span> </span>{
    <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">90.0</span>D) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">80.0</span>D) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
    }
    <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">60.0</span>D) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
    }
    <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">30.0</span>D) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span>[] SCORE_RANGES = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[] {<span class="hljs-number">90.0</span>D, <span class="hljs-number">80.0</span>D, <span class="hljs-number">60.0</span>D, <span class="hljs-number">30.0</span>D};
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getGrade</span><span class="hljs-params">(<span class="hljs-keyword">double</span> score)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; SCORE_RANGES.length; i++) {
        <span class="hljs-keyword">if</span> (score &gt;= SCORE_RANGES[i]) {
            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;
        }
    }
    <span class="hljs-keyword">return</span> SCORE_RANGES.length + <span class="hljs-number">1</span>;
}
</code></pre>
<p>思考：上面的案例返回值是递增的，所以用数组简化是没有问题的。但是，如果返回值不是递增的，能否用数组进行简化呢？答案是可以的，请自行思考解决。</p>
<h3>利用 Map 简化</h3>
<blockquote>
<p>对于映射关系的 if-else 语句，可以用Map来简化。此外，此规则同样适用于简化映射关系的 switch 语句。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java">
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getBiologyClass</span><span class="hljs-params">(String name)</span> </span>{
    <span class="hljs-keyword">switch</span> (name) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"dog"</span> :
            <span class="hljs-keyword">return</span> <span class="hljs-string">"animal"</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">"cat"</span> :
            <span class="hljs-keyword">return</span> <span class="hljs-string">"animal"</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">"lavender"</span> :
            <span class="hljs-keyword">return</span> <span class="hljs-string">"plant"</span>;
        ...
        <span class="hljs-keyword">default</span> :
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
}

</code></pre>
<p>精简</p>
<pre><code class="language-java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, String&gt; BIOLOGY_CLASS_MAP
    = ImmutableMap.&lt;String, String&gt;builder()
        .put(<span class="hljs-string">"dog"</span>, <span class="hljs-string">"animal"</span>)
        .put(<span class="hljs-string">"cat"</span>, <span class="hljs-string">"animal"</span>)
        .put(<span class="hljs-string">"lavender"</span>, <span class="hljs-string">"plant"</span>)
        ...
        .build();
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getBiologyClass</span><span class="hljs-params">(String name)</span> </span>{
    <span class="hljs-keyword">return</span> BIOLOGY_CLASS_MAP.get(name);
}
</code></pre>
<p>已经把方法简化为一行代码，其实都没有封装方法的必要了。</p>
<h3>利用容器类简化</h3>
<blockquote>
<p>Java 不像 Python 和 Go ，方法不支持返回多个对象。如果需要返回多个对象，就必须自定义类，或者利用容器类。常见的容器类有 Apache 的 Pair 类和 Triple 类， Pair 类支持返回 2 个对象， Triple 类支持返回 3 个对象。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java"><span class="hljs-meta">@Setter</span>
<span class="hljs-meta">@Getter</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PointAndDistance</span> </span>{
    <span class="hljs-keyword">private</span> Point point;
    <span class="hljs-keyword">private</span> Double distance;
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PointAndDistance <span class="hljs-title">getNearest</span><span class="hljs-params">(Point point, Point[] points)</span> </span>{
    <span class="hljs-comment">// 计算最近点和距离</span>
    ...

    <span class="hljs-comment">// 返回最近点和距离</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PointAndDistance(nearestPoint, nearestDistance);
}

</code></pre>
<p>精简</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Pair&lt;Point, Double&gt; <span class="hljs-title">getNearest</span><span class="hljs-params">(Point point, Point[] points)</span> </span>{
    <span class="hljs-comment">// 计算最近点和距离</span>
    ...

    <span class="hljs-comment">// 返回最近点和距离</span>
    <span class="hljs-keyword">return</span> ImmutablePair.of(nearestPoint, nearestDistance);
}
</code></pre>
<h3>利用 ThreadLocal 简化</h3>
<blockquote>
<p>ThreadLocal 提供了线程专有对象，可以在整个线程生命周期中随时取用，极大地方便了一些逻辑的实现。用 ThreadLocal 保存线程上下文对象，可以避免不必要的参数传递。</p>
</blockquote>
<p>普通</p>
<p>由于 DateFormat 的 format 方法线程非安全（建议使用替代方法），在线程中频繁初始化 DateFormat 性能太低，如果考虑重用只能用参数传入 DateFormat 。例子如下：</p>
<pre><code class="language-java">
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">formatDate</span><span class="hljs-params">(Date date, DateFormat format)</span> </span>{
    <span class="hljs-keyword">return</span> format.format(date);
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">getDateList</span><span class="hljs-params">(Date minDate, Date maxDate, DateFormat format)</span> </span>{
    List&lt;String&gt; dateList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    Calendar calendar = Calendar.getInstance();
    calendar.setTime(minDate);
    String currDate = formatDate(calendar.getTime(), format);
    String maxsDate = formatDate(maxDate, format);
    <span class="hljs-keyword">while</span> (currDate.compareTo(maxsDate) &lt;= <span class="hljs-number">0</span>) {
        dateList.add(currDate);
        calendar.add(Calendar.DATE, <span class="hljs-number">1</span>);
        currDate = formatDate(calendar.getTime(), format);
    }
    <span class="hljs-keyword">return</span> dateList;
}
</code></pre>
<p>精简</p>
<p>可能你会觉得以下的代码量反而多了，如果调用工具方法的地方比较多，就可以省下一大堆 DateFormat 初始化和传入参数的代码。</p>
<pre><code class="language-java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;DateFormat&gt; LOCAL_DATE_FORMAT = <span class="hljs-keyword">new</span> ThreadLocal&lt;DateFormat&gt;() {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> DateFormat <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyyMMdd"</span>);
    }
};

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">formatDate</span><span class="hljs-params">(Date date)</span> </span>{
    <span class="hljs-keyword">return</span> LOCAL_DATE_FORMAT.get().format(date);
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">getDateList</span><span class="hljs-params">(Date minDate, Date maxDate)</span> </span>{
    List&lt;String&gt; dateList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    Calendar calendar = Calendar.getInstance();
    calendar.setTime(minDate);
    String currDate = formatDate(calendar.getTime());
    String maxsDate = formatDate(maxDate);
    <span class="hljs-keyword">while</span> (currDate.compareTo(maxsDate) &lt;= <span class="hljs-number">0</span>) {
        dateList.add(currDate);
        calendar.add(Calendar.DATE, <span class="hljs-number">1</span>);
        currDate = formatDate(calendar.getTime());
    }
    <span class="hljs-keyword">return</span> dateList;
}
</code></pre>
<ul>
<li>注意：ThreadLocal 有一定的内存泄露的风险，尽量在业务代码结束前调用 remove 方法进行数据清除。</li>
</ul>
<h2>利用 Optional</h2>
<blockquote>
<p>在 Java 8 里，引入了一个 Optional 类，该类是一个可以为 null 的容器对象。</p>
</blockquote>
<h3>保证值存在</h3>
<p>普通</p>
<pre><code class="language-java">Integer thisValue;
<span class="hljs-keyword">if</span> (Objects.nonNull(value)) {
    thisValue = value;
} <span class="hljs-keyword">else</span> {
    thisValue = DEFAULT_VALUE;
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">Integer thisValue = Optional.ofNullable(value).orElse(DEFAULT_VALUE);
</code></pre>
<h3>保证值合法</h3>
<p>普通</p>
<pre><code class="language-java">
Integer thisValue;
<span class="hljs-keyword">if</span> (Objects.nonNull(value) &amp;&amp; value.compareTo(MAX_VALUE) &lt;= <span class="hljs-number">0</span>) {
    thisValue = value;
} <span class="hljs-keyword">else</span> {
    thisValue = MAX_VALUE;
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">
Integer thisValue = Optional.ofNullable(value)
    .filter(tempValue -&gt; tempValue.compareTo(MAX_VALUE) &lt;= <span class="hljs-number">0</span>).orElse(MAX_VALUE);

</code></pre>
<h3>避免空判断</h3>
<p>普通</p>
<pre><code class="language-java">String zipcode = <span class="hljs-keyword">null</span>;
<span class="hljs-keyword">if</span> (Objects.nonNull(user)) {
    Address address = user.getAddress();
    <span class="hljs-keyword">if</span> (Objects.nonNull(address)) {
        Country country = address.getCountry();
        <span class="hljs-keyword">if</span> (Objects.nonNull(country)) {
            zipcode = country.getZipcode();
        }
    }
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">
String zipcode = Optional.ofNullable(user).map(User::getAddress)
    .map(Address::getCountry).map(Country::getZipcode).orElse(<span class="hljs-keyword">null</span>);
</code></pre>
<h2>利用 Stream</h2>
<blockquote>
<p>流（Stream）是Java 8的新成员，允许你以声明式处理数据集合，可以看成为一个遍历数据集的高级迭代器。流主要有三部分构成：获取一个数据源→数据转换→执行操作获取想要的结果。每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象，这就允许对其操作可以像链条一样排列，形成了一个管道。流（Stream）提供的功能非常有用，主要包括匹配、过滤、汇总、转化、分组、分组汇总等功能。</p>
</blockquote>
<h3>匹配集合数据</h3>
<p>普通</p>
<pre><code class="language-java">
<span class="hljs-keyword">boolean</span> isFound = <span class="hljs-keyword">false</span>;
<span class="hljs-keyword">for</span> (UserDO user : userList) {
    <span class="hljs-keyword">if</span> (Objects.equals(user.getId(), userId)) {
        isFound = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">break</span>;
    }
}
</code></pre>
<p>精简</p>
<pre><code class="language-java"><span class="hljs-keyword">boolean</span> isFound = userList.stream()
    .anyMatch(user -&gt; Objects.equals(user.getId(), userId));
</code></pre>
<h3>过滤集合数据</h3>
<p>普通</p>
<pre><code class="language-java">
List&lt;UserDO&gt; resultList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
<span class="hljs-keyword">for</span> (UserDO user : userList) {
    <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(user.getIsSuper())) {
        resultList.add(user);
    }
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">List&lt;UserDO&gt; resultList = userList.stream()
    .filter(user -&gt; Boolean.TRUE.equals(user.getIsSuper()))
    .collect(Collectors.toList());
</code></pre>
<h3>汇总集合数据</h3>
<p>普通</p>
<pre><code class="language-java"><span class="hljs-keyword">double</span> total = <span class="hljs-number">0.0</span>D;
<span class="hljs-keyword">for</span> (Account account : accountList) {
    total += account.getBalance();
}
</code></pre>
<p>精简</p>
<pre><code class="language-java"><span class="hljs-keyword">double</span> total = accountList.stream().mapToDouble(Account::getBalance).sum();
</code></pre>
<h3>转化集合数据</h3>
<p>普通</p>
<pre><code class="language-java">List&lt;UserVO&gt; userVOList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
<span class="hljs-keyword">for</span> (UserDO userDO : userDOList) {
    userVOList.add(transUser(userDO));
}

</code></pre>
<p>精简</p>
<pre><code class="language-java">
List&lt;UserVO&gt; userVOList = userDOList.stream()
    .map(<span class="hljs-keyword">this</span>::transUser).collect(Collectors.toList());
</code></pre>
<h3>分组集合数据</h3>
<p>普通</p>
<pre><code class="language-java">
Map&lt;Long, List&lt;UserDO&gt;&gt; roleUserMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
<span class="hljs-keyword">for</span> (UserDO userDO : userDOList) {
    roleUserMap.computeIfAbsent(userDO.getRoleId(), key -&gt; <span class="hljs-keyword">new</span> ArrayList&lt;&gt;())
        .add(userDO);
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">
Map&lt;Long, List&lt;UserDO&gt;&gt; roleUserMap = userDOList.stream()
    .collect(Collectors.groupingBy(UserDO::getRoleId));
</code></pre>
<h3>分组汇总集合</h3>
<p>普通</p>
<pre><code class="language-java">
Map&lt;Long, Double&gt; roleTotalMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
<span class="hljs-keyword">for</span> (Account account : accountList) {
    Long roleId = account.getRoleId();
    Double total = Optional.ofNullable(roleTotalMap.get(roleId)).orElse(<span class="hljs-number">0.0</span>D);
    roleTotalMap.put(roleId, total + account.getBalance());
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">
roleTotalMap = accountList.stream().collect(Collectors.groupingBy(Account::getRoleId, Collectors.summingDouble(Account::getBalance)));

</code></pre>
<h3>生成范围集合</h3>
<blockquote>
<p>Python 的 range 非常方便，Stream 也提供了类似的方法。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java"><span class="hljs-keyword">int</span>[] array1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
    array1[i] = i + <span class="hljs-number">1</span>;
}

<span class="hljs-keyword">int</span>[] array2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N];
array2[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) {
    array2[i] = array2[i - <span class="hljs-number">1</span>] * <span class="hljs-number">2</span>;
}

</code></pre>
<p>精简</p>
<pre><code class="language-java"><span class="hljs-keyword">int</span>[] array1 = IntStream.rangeClosed(<span class="hljs-number">1</span>, N).toArray();
<span class="hljs-keyword">int</span>[] array2 = IntStream.iterate(<span class="hljs-number">1</span>, n -&gt; n * <span class="hljs-number">2</span>).limit(N).toArray();
</code></pre>
<h2>利用程序结构</h2>
<h3>返回条件表达式</h3>
<blockquote>
<p>条件表达式判断返回布尔值，条件表达式本身就是结果。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java">
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSuper</span><span class="hljs-params">(Long userId)</span>
    UserDO user </span>= userDAO.get(userId);
    <span class="hljs-keyword">if</span> (Objects.nonNull(user) &amp;&amp; Boolean.TRUE.equals(user.getIsSuper())) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSuper</span><span class="hljs-params">(Long userId)</span>
    UserDO user </span>= userDAO.get(userId);
    <span class="hljs-keyword">return</span> Objects.nonNull(user) &amp;&amp; Boolean.TRUE.equals(user.getIsSuper());
}
</code></pre>
<h3>最小化条件作用域</h3>
<blockquote>
<p>最小化条件作用域，尽量提出公共处理代码。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java">Result result = summaryService.reportWorkDaily(workDaily);
<span class="hljs-keyword">if</span> (result.isSuccess()) {
    String message = <span class="hljs-string">"上报工作日报成功"</span>;
    dingtalkService.sendMessage(user.getPhone(), message);
} <span class="hljs-keyword">else</span> {
    String message = <span class="hljs-string">"上报工作日报失败:"</span> + result.getMessage();
    log.warn(message);
    dingtalkService.sendMessage(user.getPhone(), message);
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">String message;
Result result = summaryService.reportWorkDaily(workDaily);
<span class="hljs-keyword">if</span> (result.isSuccess()) {
    message = <span class="hljs-string">"上报工作日报成功"</span>;
} <span class="hljs-keyword">else</span> {
    message = <span class="hljs-string">"上报工作日报失败:"</span> + result.getMessage();
    log.warn(message);
}
dingtalkService.sendMessage(user.getPhone(), message);
</code></pre>
<h3>调整表达式位置</h3>
<blockquote>
<p>调整表达式位置，在逻辑不变的前提下，让代码变得更简洁。</p>
</blockquote>
<p>普通1</p>
<pre><code class="language-java">
String line = readLine();
<span class="hljs-keyword">while</span> (Objects.nonNull(line)) {
    ... <span class="hljs-comment">// 处理逻辑代码</span>
    line = readLine();
}
</code></pre>
<p>普通2</p>
<pre><code class="language-java"><span class="hljs-keyword">for</span> (String line = readLine(); Objects.nonNull(line); line = readLine()) {
    ... <span class="hljs-comment">// 处理逻辑代码</span>
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">
String line;
<span class="hljs-keyword">while</span> (Objects.nonNull(line = readLine())) {
    ... <span class="hljs-comment">// 处理逻辑代码</span>
}
</code></pre>
<ul>
<li>注意：有些规范可能不建议这种精简写法。</li>
</ul>
<h3>利用非空对象</h3>
<blockquote>
<p>在比较对象时，交换对象位置，利用非空对象，可以避免空指针判断。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java">
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_VALUE = <span class="hljs-number">1000</span>;
<span class="hljs-keyword">boolean</span> isMax = (value != <span class="hljs-keyword">null</span> &amp;&amp; value.equals(MAX_VALUE));
<span class="hljs-keyword">boolean</span> isTrue = (result != <span class="hljs-keyword">null</span> &amp;&amp; result.equals(Boolean.TRUE));

</code></pre>
<p>精简</p>
<pre><code class="language-java">
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer MAX_VALUE = <span class="hljs-number">1000</span>;
<span class="hljs-keyword">boolean</span> isMax = MAX_VALUE.equals(value);
<span class="hljs-keyword">boolean</span> isTrue = Boolean.TRUE.equals(result);
</code></pre>
<h2>利用设计模式</h2>
<h3>模板方法模式</h3>
<blockquote>
<p>模板方法模式（Template Method Pattern）定义一个固定的算法框架，而将算法的一些步骤放到子类中实现，使得子类可以在不改变算法框架的情况下重定义该算法的某些步骤。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java"><span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserValue</span> </span>{
    <span class="hljs-comment">/** 值操作 */</span>
    <span class="hljs-meta">@Resource</span>(name = <span class="hljs-string">"stringRedisTemplate"</span>)
    <span class="hljs-keyword">private</span> ValueOperations&lt;String, String&gt; valueOperations;
    <span class="hljs-comment">/** 值模式 */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String KEY_FORMAT = <span class="hljs-string">"Value:User:%s"</span>;

    <span class="hljs-comment">/** 设置值 */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(Long id, UserDO value)</span> </span>{
        String key = String.format(KEY_FORMAT, id);
        valueOperations.set(key, JSON.toJSONString(value));
    }

    <span class="hljs-comment">/** 获取值 */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDO <span class="hljs-title">get</span><span class="hljs-params">(Long id)</span> </span>{
        String key = String.format(KEY_FORMAT, id);
        String value = valueOperations.get(key);
        <span class="hljs-keyword">return</span> JSON.parseObject(value, UserDO.class);
    }

    ...
}

<span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleValue</span> </span>{
    <span class="hljs-comment">/** 值操作 */</span>
    <span class="hljs-meta">@Resource</span>(name = <span class="hljs-string">"stringRedisTemplate"</span>)
    <span class="hljs-keyword">private</span> ValueOperations&lt;String, String&gt; valueOperations;
    <span class="hljs-comment">/** 值模式 */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String KEY_FORMAT = <span class="hljs-string">"Value:Role:%s"</span>;

    <span class="hljs-comment">/** 设置值 */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(Long id, RoleDO value)</span> </span>{
        String key = String.format(KEY_FORMAT, id);
        valueOperations.set(key, JSON.toJSONString(value));
    }

    <span class="hljs-comment">/** 获取值 */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> RoleDO <span class="hljs-title">get</span><span class="hljs-params">(Long id)</span> </span>{
        String key = String.format(KEY_FORMAT, id);
        String value = valueOperations.get(key);
        <span class="hljs-keyword">return</span> JSON.parseObject(value, RoleDO.class);
    }

    ...
}

</code></pre>
<p>精简</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractDynamicValue</span>&lt;<span class="hljs-title">I</span>, <span class="hljs-title">V</span>&gt; </span>{
    <span class="hljs-comment">/** 值操作 */</span>
    <span class="hljs-meta">@Resource</span>(name = <span class="hljs-string">"stringRedisTemplate"</span>)
    <span class="hljs-keyword">private</span> ValueOperations&lt;String, String&gt; valueOperations;

    <span class="hljs-comment">/** 设置值 */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(I id, V value)</span> </span>{
        valueOperations.set(getKey(id), JSON.toJSONString(value));
    }

    <span class="hljs-comment">/** 获取值 */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(I id)</span> </span>{
        <span class="hljs-keyword">return</span> JSON.parseObject(valueOperations.get(getKey(id)), getValueClass());
    }

    ...

    <span class="hljs-comment">/** 获取主键 */</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getKey</span><span class="hljs-params">(I id)</span></span>;

    <span class="hljs-comment">/** 获取值类 */</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Class&lt;V&gt; <span class="hljs-title">getValueClass</span><span class="hljs-params">()</span></span>;
}

<span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserValue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractValue</span>&lt;<span class="hljs-title">Long</span>, <span class="hljs-title">UserDO</span>&gt; </span>{
    <span class="hljs-comment">/** 获取主键 */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">getKey</span><span class="hljs-params">(Long id)</span> </span>{
        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">"Value:User:%s"</span>, id);
    }

    <span class="hljs-comment">/** 获取值类 */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> Class&lt;UserDO&gt; <span class="hljs-title">getValueClass</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> UserDO.class;
    }
}

<span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleValue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractValue</span>&lt;<span class="hljs-title">Long</span>, <span class="hljs-title">RoleDO</span>&gt; </span>{
    <span class="hljs-comment">/** 获取主键 */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">getKey</span><span class="hljs-params">(Long id)</span> </span>{
        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">"Value:Role:%s"</span>, id);
    }

    <span class="hljs-comment">/** 获取值类 */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> Class&lt;RoleDO&gt; <span class="hljs-title">getValueClass</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> RoleDO.class;
    }
}
</code></pre>
<h3>建造者模式</h3>
<blockquote>
<p>建造者模式（Builder Pattern）将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DataHandler</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
    <span class="hljs-comment">/** 解析数据 */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">parseData</span><span class="hljs-params">(Record record)</span></span>;

    <span class="hljs-comment">/** 存储数据 */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">storeData</span><span class="hljs-params">(List&lt;T&gt; dataList)</span></span>;
}

<span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">executeFetch</span><span class="hljs-params">(String tableName, <span class="hljs-keyword">int</span> batchSize, DataHandler&lt;T&gt; dataHandler)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-comment">// 构建下载会话</span>
    DownloadSession session = buildSession(tableName);

    <span class="hljs-comment">// 获取数据数量</span>
    <span class="hljs-keyword">long</span> recordCount = session.getRecordCount();
    <span class="hljs-keyword">if</span> (recordCount == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">// 进行数据读取</span>
    <span class="hljs-keyword">long</span> fetchCount = <span class="hljs-number">0L</span>;
    <span class="hljs-keyword">try</span> (RecordReader reader = session.openRecordReader(<span class="hljs-number">0L</span>, recordCount, <span class="hljs-keyword">true</span>)) {
        <span class="hljs-comment">// 依次读取数据</span>
        Record record;
        List&lt;T&gt; dataList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(batchSize);
        <span class="hljs-keyword">while</span> ((record = reader.read()) != <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// 解析添加数据</span>
            T data = dataHandler.parseData(record);
            <span class="hljs-keyword">if</span> (Objects.nonNull(data)) {
                dataList.add(data);
            }

            <span class="hljs-comment">// 批量存储数据</span>
            <span class="hljs-keyword">if</span> (dataList.size() == batchSize) {
                <span class="hljs-keyword">boolean</span> isContinue = dataHandler.storeData(dataList);
                fetchCount += batchSize;
                dataList.clear();
                <span class="hljs-keyword">if</span> (!isContinue) {
                    <span class="hljs-keyword">break</span>;
                }
            }
        }

        <span class="hljs-comment">// 存储剩余数据</span>
        <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(dataList)) {
            dataHandler.storeData(dataList);
            fetchCount += dataList.size();
            dataList.clear();
        }
    }

    <span class="hljs-comment">// 返回获取数量</span>
    <span class="hljs-keyword">return</span> fetchCount;
}

 <span class="hljs-comment">// 使用案例</span>
<span class="hljs-keyword">long</span> fetchCount = odpsService.executeFetch(<span class="hljs-string">"user"</span>, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> DataHandler() {
    <span class="hljs-comment">/** 解析数据 */</span>
    <span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">parseData</span><span class="hljs-params">(Record record)</span> </span>{
        UserDO user = <span class="hljs-keyword">new</span> UserDO();
        user.setId(record.getBigint(<span class="hljs-string">"id"</span>));
        user.setName(record.getString(<span class="hljs-string">"name"</span>));
        <span class="hljs-keyword">return</span> user;
    }

    <span class="hljs-comment">/** 存储数据 */</span>
    <span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">storeData</span><span class="hljs-params">(List&lt;T&gt; dataList)</span> </span>{
        userDAO.batchInsert(dataList);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
});
</code></pre>
<p>精简</p>
<pre><code class="language-java">
<span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">executeFetch</span><span class="hljs-params">(String tableName, <span class="hljs-keyword">int</span> batchSize, Function&lt;Record, T&gt; dataParser, Function&lt;List&lt;T&gt;, Boolean&gt; dataStorage)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    <span class="hljs-comment">// 构建下载会话</span>
    DownloadSession session = buildSession(tableName);

    <span class="hljs-comment">// 获取数据数量</span>
    <span class="hljs-keyword">long</span> recordCount = session.getRecordCount();
    <span class="hljs-keyword">if</span> (recordCount == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">// 进行数据读取</span>
    <span class="hljs-keyword">long</span> fetchCount = <span class="hljs-number">0L</span>;
    <span class="hljs-keyword">try</span> (RecordReader reader = session.openRecordReader(<span class="hljs-number">0L</span>, recordCount, <span class="hljs-keyword">true</span>)) {
        <span class="hljs-comment">// 依次读取数据</span>
        Record record;
        List&lt;T&gt; dataList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(batchSize);
        <span class="hljs-keyword">while</span> ((record = reader.read()) != <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// 解析添加数据</span>
            T data = dataParser.apply(record);
            <span class="hljs-keyword">if</span> (Objects.nonNull(data)) {
                dataList.add(data);
            }

            <span class="hljs-comment">// 批量存储数据</span>
            <span class="hljs-keyword">if</span> (dataList.size() == batchSize) {
                Boolean isContinue = dataStorage.apply(dataList);
                fetchCount += batchSize;
                dataList.clear();
                <span class="hljs-keyword">if</span> (!Boolean.TRUE.equals(isContinue)) {
                    <span class="hljs-keyword">break</span>;
                }
            }
        }

        <span class="hljs-comment">// 存储剩余数据</span>
        <span class="hljs-keyword">if</span> (CollectionUtils.isNotEmpty(dataList)) {
            dataStorage.apply(dataList);
            fetchCount += dataList.size();
            dataList.clear();
        }
    }

    <span class="hljs-comment">// 返回获取数量</span>
    <span class="hljs-keyword">return</span> fetchCount;
}

 <span class="hljs-comment">// 使用案例</span>
<span class="hljs-keyword">long</span> fetchCount = odpsService.executeFetch(<span class="hljs-string">"user"</span>, <span class="hljs-number">5000</span>, record -&gt; {
        UserDO user = <span class="hljs-keyword">new</span> UserDO();
        user.setId(record.getBigint(<span class="hljs-string">"id"</span>));
        user.setName(record.getString(<span class="hljs-string">"name"</span>));
        <span class="hljs-keyword">return</span> user;
    }, dataList -&gt; {
        userDAO.batchInsert(dataList);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    });

</code></pre>
<p>普通的建造者模式，实现时需要定义 DataHandler 接口，调用时需要实现 DataHandler 匿名内部类，代码较多较繁琐。而精简后的建造者模式，充分利用了函数式编程，实现时无需定义接口，直接使用 Function 接口；调用时无需实现匿名内部类，直接采用 lambda 表达式，代码较少较简洁。</p>
<h3>代理模式</h3>
<blockquote>
<p>Spring 中最重要的代理模式就是 AOP (Aspect-Oriented Programming，面向切面的编程)，是使用 JDK 动态代理和 CGLIB 动态代理技术来实现的。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java">
<span class="hljs-meta">@Slf</span>4j
<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>{
    <span class="hljs-comment">/** 用户服务 */</span>
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserService userService;

    <span class="hljs-comment">/** 查询用户 */</span>
    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/queryUser"</span>)
    <span class="hljs-keyword">public</span> Result&lt;?&gt; queryUser(<span class="hljs-meta">@RequestBody</span> <span class="hljs-meta">@Valid</span> UserQueryVO query) {
        <span class="hljs-keyword">try</span> {
            PageDataVO&lt;UserVO&gt; pageData = userService.queryUser(query);
            <span class="hljs-keyword">return</span> Result.success(pageData);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            log.error(e.getMessage(), e);
            <span class="hljs-keyword">return</span> Result.failure(e.getMessage());
        }
    }
    ...
}
</code></pre>
<p>精简1</p>
<p>基于  @ControllerAdvice 的异常处理：</p>
<pre><code class="language-java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>{
    <span class="hljs-comment">/** 用户服务 */</span>
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserService userService;

    <span class="hljs-comment">/** 查询用户 */</span>
    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/queryUser"</span>)
    <span class="hljs-keyword">public</span> Result&lt;PageDataVO&lt;UserVO&gt;&gt; queryUser(<span class="hljs-meta">@RequestBody</span> <span class="hljs-meta">@Valid</span> UserQueryVO query) {
        PageDataVO&lt;UserVO&gt; pageData = userService.queryUser(query);
        <span class="hljs-keyword">return</span> Result.success(pageData);
    }
    ...
}

<span class="hljs-meta">@Slf</span>4j
<span class="hljs-meta">@ControllerAdvice</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalControllerAdvice</span> </span>{
    <span class="hljs-comment">/** 处理异常 */</span>
    <span class="hljs-meta">@ResponseBody</span>
    <span class="hljs-meta">@ExceptionHandler</span>(Exception.class)
    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;Void&gt; <span class="hljs-title">handleException</span><span class="hljs-params">(Exception e)</span> </span>{
        log.error(e.getMessage(), e);
        <span class="hljs-keyword">return</span> Result.failure(e.getMessage());
    }
}
</code></pre>
<p>精简2</p>
<p>基于 AOP 的异常处理：</p>
<pre><code class="language-java"><span class="hljs-comment">// UserController代码同"精简1"</span>

<span class="hljs-meta">@Slf</span>4j
<span class="hljs-meta">@Aspect</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebExceptionAspect</span> </span>{
    <span class="hljs-comment">/** 点切面 */</span>
    <span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"@annotation(org.springframework.web.bind.annotation.RequestMapping)"</span>)
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">webPointcut</span><span class="hljs-params">()</span> </span>{}

    <span class="hljs-comment">/** 处理异常 */</span>
    <span class="hljs-meta">@AfterThrowing</span>(pointcut = <span class="hljs-string">"webPointcut()"</span>, throwing = <span class="hljs-string">"e"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleException</span><span class="hljs-params">(Exception e)</span> </span>{
        Result&lt;Void&gt; result = Result.failure(e.getMessage());
        writeContent(JSON.toJSONString(result));
    }
    ...
}
</code></pre>
<h2>利用删除代码</h2>
<blockquote>
<p>“少即是多”，“少”不是空白而是精简，“多”不是拥挤而是完美。删除多余的代码，才能使代码更精简更完美。</p>
</blockquote>
<h3>删除已废弃的代码</h3>
<blockquote>
<p>删除项目中的已废弃的包、类、字段、方法、变量、常量、导入、注解、注释、已注释代码、Maven包导入、MyBatis的SQL语句、属性配置字段等，可以精简项目代码便于维护。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;
<span class="hljs-meta">@Slf</span>4j
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductService</span> </span>{
    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"discardRate"</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> discardRate;
    ...
    <span class="hljs-function"><span class="hljs-keyword">private</span> ProductVO <span class="hljs-title">transProductDO</span><span class="hljs-params">(ProductDO productDO)</span> </span>{
        ProductVO productVO = <span class="hljs-keyword">new</span> ProductVO();
        BeanUtils.copyProperties(productDO, productVO);
        <span class="hljs-comment">// productVO.setPrice(getDiscardPrice(productDO.getPrice()));</span>
        <span class="hljs-keyword">return</span> productVO;
    }
    <span class="hljs-function"><span class="hljs-keyword">private</span> BigDecimal <span class="hljs-title">getDiscardPrice</span><span class="hljs-params">(BigDecimal originalPrice)</span> </span>{
        ...
    }
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductService</span> </span>{
    ...
    <span class="hljs-function"><span class="hljs-keyword">private</span> ProductVO <span class="hljs-title">transProductDO</span><span class="hljs-params">(ProductDO productDO)</span> </span>{
        ProductVO productVO = <span class="hljs-keyword">new</span> ProductVO();
        BeanUtils.copyProperties(productDO, productVO);
        <span class="hljs-keyword">return</span> productVO;
    }
}
</code></pre>
<h3>删除接口方法的public</h3>
<blockquote>
<p>对于接口(interface)，所有的字段和方法都是 public 的，可以不用显式声明为 public 。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java">
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDAO</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">countUser</span><span class="hljs-params">(@Param(<span class="hljs-string">"query"</span>)</span> UserQuery query)</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserDO&gt; <span class="hljs-title">queryUser</span><span class="hljs-params">(@Param(<span class="hljs-string">"query"</span>)</span> UserQuery query)</span>;
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDAO</span> </span>{
    <span class="hljs-function">Long <span class="hljs-title">countUser</span><span class="hljs-params">(@Param(<span class="hljs-string">"query"</span>)</span> UserQuery query)</span>;
    <span class="hljs-function">List&lt;UserDO&gt; <span class="hljs-title">queryUser</span><span class="hljs-params">(@Param(<span class="hljs-string">"query"</span>)</span> UserQuery query)</span>;
}
</code></pre>
<h3>删除枚举构造方法的 private</h3>
<blockquote>
<p>对于枚举(menu)，构造方法都是 private 的，可以不用显式声明为 private 。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> UserStatus {
    DISABLED(<span class="hljs-number">0</span>, <span class="hljs-string">"禁用"</span>),
    ENABLED(<span class="hljs-number">1</span>, <span class="hljs-string">"启用"</span>);
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer value;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String desc;
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">UserStatus</span><span class="hljs-params">(Integer value, String desc)</span> </span>{
        <span class="hljs-keyword">this</span>.value = value;
        <span class="hljs-keyword">this</span>.desc = desc;
    }
    ...
}
</code></pre>
<p>精简</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> UserStatus {
    DISABLED(<span class="hljs-number">0</span>, <span class="hljs-string">"禁用"</span>),
    ENABLED(<span class="hljs-number">1</span>, <span class="hljs-string">"启用"</span>);
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer value;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String desc;
    UserStatus(Integer value, String desc) {
        <span class="hljs-keyword">this</span>.value = value;
        <span class="hljs-keyword">this</span>.desc = desc;
    }
    ...
}
</code></pre>
<h3>删除 final 类方法的 final</h3>
<blockquote>
<p>对于 final 类，不能被子类继承，所以其方法不会被覆盖，没有必要添加 final 修饰。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Rectangle implements Shape {
    ...
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> width * height;
    }
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Rectangle implements Shape {
    ...
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> width * height;
    }
}
</code></pre>
<h3>删除基类 implements 的接口</h3>
<blockquote>
<p>如果基类已 implements 某接口，子类没有必要再 implements 该接口，只需要直接实现接口方法即可。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Shape</span> </span>{
    ...
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span></span>;
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> AbstractShape implements Shape {
    ...
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Rectangle extends AbstractShape implements Shape {
    ...
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> width * height;
    }
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">
...
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Rectangle extends AbstractShape {
    ...
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> width * height;
    }
}
</code></pre>
<h3>删除不必要的变量</h3>
<blockquote>
<p>不必要的变量，只会让代码看起来更繁琐。</p>
</blockquote>
<p>普通</p>
<pre><code class="language-java">
<span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">existsUser</span><span class="hljs-params">(Long userId)</span> </span>{
    Boolean exists = userDAO.exists(userId);
    <span class="hljs-keyword">return</span> exists;
}
</code></pre>
<p>精简</p>
<pre><code class="language-java">
<span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">existsUser</span><span class="hljs-params">(Long userId)</span> </span>{
    <span class="hljs-keyword">return</span> userDAO.exists(userId);
}
</code></pre>
</section><footer class="footer-container"><div class="footer-body"><img src="/img/dubbo_gray.png"/><div class="cols-container"><div class="col col-12"><h3>Disclaimer</h3><p>the disclaimer content</p></div><div class="col col-6"><dl><dt>Documentation</dt><dd><a href="/en-us/docs/introduction.html" target="_self">Overview</a></dd><dd><a href="/en-us/docs/introduction.html" target="_self">Quick start</a></dd><dd><a href="/en-us/docs/dir/introduction.html" target="_self">Developer guide</a></dd></dl></div><div class="col col-6"><dl><dt>Resources</dt><dd><a href="/en-us/blog/index.html" target="_self">Blog</a></dd><dd><a href="/en-us/community/index.html" target="_self">Community</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2019 BurningMyself</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/blogDetail.js"></script>
</body>
</html>