{
  "filename": "mkdocs.md",
  "__html": "<h1>mkdocs简单使用</h1>\n<p><a href=\"http://www.mkdocs.org/\">官网</a></p>\n<h2>一、安装</h2>\n<pre><code class=\"language-python\"><span class=\"hljs-comment\"># 查看 python 版本</span>\npython --version\n<span class=\"hljs-comment\"># Python 2.7.2</span>\n\n<span class=\"hljs-comment\"># 查看 pip 版本</span>\npip --version\n<span class=\"hljs-comment\"># pip 1.5.2</span>\n\n<span class=\"hljs-comment\"># 更新 pip</span>\npip install --upgrade pip\n\n<span class=\"hljs-comment\"># 安装 mkdocs</span>\npip install mkdocs\npip install --upgrade mkdocs\n\n<span class=\"hljs-comment\"># 查看 mkdocs 版本</span>\nmkdocs --version\n<span class=\"hljs-comment\"># mkdocs, version 0.17.3</span>\n\n<span class=\"hljs-comment\"># 查看帮助</span>\nmkdocs --help\n<span class=\"hljs-comment\"># 查看具体命令的帮助</span>\nmkdocs build --help\n\n<span class=\"hljs-comment\"># get started</span>\nmkdocs new my-project\ncd my-project\n\n<span class=\"hljs-comment\"># 实时测试</span>\nmkdocs serve -a <span class=\"hljs-number\">0.0</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>:<span class=\"hljs-number\">8000</span>\n\n<span class=\"hljs-comment\"># 打包成静态文件</span>\nmkdocs build --clean\n<span class=\"hljs-comment\"># 打包到特定文件夹</span>\nmkdocs build --clean -d ./myFiles\n</code></pre>\n<h2>二、配置文件</h2>\n<p>默认使用的配置文件是 ./mkdocs.yml\n使用的目录是 ./docs/\n./mkdocs.yml 配置文件的一般内容是:</p>\n<pre><code class=\"language-yml\"><span class=\"hljs-attr\">site_name:</span> <span class=\"hljs-string\">webSite_Title</span>\n<span class=\"hljs-attr\">pages:</span>\n<span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">index.md</span>\n<span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">about.md</span>\n\n<span class=\"hljs-attr\">theme:</span> <span class=\"hljs-string\">readthedocs</span>\n</code></pre>\n<p>如果不配置 pages , 那么 mkdocs 会自动遍历检索 ./docs 目录中的所有 md 文档，并生成 pages 内容,但是是按照字母顺序排序的，如果需要，还是手动设置 pages 内容\npages 使用 HOME 作为 <a href=\"http://index.md\">index.md</a> 的标题 , About 作为 <a href=\"http://about.md\">about.md</a> 的标题\n并且使用 <a href=\"http://index.md\">index.md</a> 作为显示首页, pages 中没有配置 <a href=\"http://index.md\">index.md</a> 首页会无法显示\n所以一般的配置都是</p>\n<pre><code class=\"language-yml\"><span class=\"hljs-attr\">pages:</span>\n<span class=\"hljs-attr\">- Home:</span> <span class=\"hljs-string\">index.md</span>\n<span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">User</span> <span class=\"hljs-attr\">Guide:</span>\n<span class=\"hljs-bullet\">    -</span> <span class=\"hljs-string\">'Writing your docs'</span><span class=\"hljs-string\">:</span> <span class=\"hljs-string\">'user-guide/writing-your-docs.md'</span>\n<span class=\"hljs-bullet\">    -</span> <span class=\"hljs-string\">'Styling your docs'</span><span class=\"hljs-string\">:</span> <span class=\"hljs-string\">'user-guide/styling-your-docs.md'</span>\n<span class=\"hljs-attr\">- About:</span>\n<span class=\"hljs-attr\">    - 'License':</span> <span class=\"hljs-string\">'about/license.md'</span>\n<span class=\"hljs-bullet\">    -</span> <span class=\"hljs-string\">'Release Notes'</span><span class=\"hljs-string\">:</span> <span class=\"hljs-string\">'about/release-notes.md'</span>\n</code></pre>\n<p>mkdocs 包含了两个内置的 theme: mkdocs 和 readthedocs\nmkdocs 是默认的theme\n当然你也可以创建自己的theme,或使用第三方theme，例如</p>\n<pre><code class=\"language-python\">pip install windmill\npip install --upgrade windmill\n\n<span class=\"hljs-comment\"># 然后指定 theme: windmill</span>\n</code></pre>\n<p>docs_dir 可以让你指定 docs/ 目录的位置\nsite_dir 可以让你指定 build后的输出目录位置\ndev_addr 可以让你指定 serve 时监听的 IP:port</p>\n<p>还有 plugins</p>\n<h2>三、简单配置</h2>\n<pre><code class=\"language-python\">#!/bin/bash\n\n# ================ 基础功能区 ================ \nscriptDir=$(dirname $(readlink -f $0))  \nscriptName=$(basename $0)\n\n\n# ================ 函数定义区 ================\n# 获取git项目名称映射的中文名称,retCode=155表示映射到了\nfunction getMapNameForGitProjectName {\n\n  # 第一个参数是 git项目名称\n  local gitProjectName=\"$1\"\n  # 获取git项目名称为 xxx.git \n  local tmpBaseName=$(basename ${gitProjectName})\n  # 去掉 .git\n  local tmpOriProjName=${tmpBaseName%.*}\n  \n  # 声明使用的映射文件\n  local tmpMappingFile=\"${scriptDir}/mapForProject.txt\"\n  if (! [ -e ${tmpMappingFile} ]);then\n    echo ${tmpOriProjName}\n    return 0\n  fi\n  \n  # 查找 git项目名称:yyy 中冒号后面的部分\n  local tmpMappedName=$(grep -oP \"(?&lt;=${tmpOriProjName}:).*$\" ${tmpMappingFile})\n  if ([ -n \"${tmpMappedName}\" ]);then\n    echo ${tmpMappedName}\n    return 155\n  else\n    echo ${tmpOriProjName} \n  fi\n\n}\n\n# 遍历 映射文件, 匹配nginx根目录中的文件夹,生成连接\nfunction doAddLinkForProjectInMap {\n  # 第一个参数是 nginx根目录\n  local nginxRootDir=\"$1\"\n\n  # 第二个参数是 index.html ，表示要追加内容的文件\n  local indexFile=\"$2\"\n\n  if ([ -z \"${nginxRootDir}\" ]);then\n    echo \"为doAddLinkForProjectInMap函数提供的参数错误\"\n    return 1\n  fi \n\n  if ([ -z \"${indexFile}\" ]);then\n    echo \"为doAddLinkForProjectInMap函数提供的参数错误\"\n    return 1\n  fi \n\n  # 声明使用的映射文件\n  local tmpMappingFile=\"${scriptDir}/mapForProject.txt\"\n  if (! [ -e ${tmpMappingFile} ]);then\n    echo \"映射文件不存在\"\n    return 1\n  fi\n\n  # 追加 ul 到 indexFile\n  cat &gt;&gt; ${indexFile} &lt;&lt;EOF\n&lt;ul&gt;\nEOF\n\n  for line in `cat ${tmpMappingFile}`;do \n    # 获取每一行冒号前面的部分\n    tmpDirName=${line%%:*} # 匹配 $string的后缀 的最长匹配,然后删除,支持正则表达式\n    tmpMapName=${line#*:} # 匹配 $string的前缀 的最短匹配,然后删除,支持正则表达式\n    \n    if ([ -z \"${tmpDirName}\" ]);then\n      continue\n    fi\n\n    if ([ -e \"${nginxRootDir}/${tmpDirName}\" ]);then\n      # 如果存在该文件夹\n      echo \"&lt;li&gt;&lt;a href=\\\"./${tmpDirName}\\\" target=\\\"_self\\\"&gt;${tmpMapName}&lt;/a&gt;&lt;/li&gt;\" &gt;&gt; ${indexFile}\n    fi\n  done\n\n  # 追加 /ul\n  cat &gt;&gt; ${nginxDir}/index.html &lt;&lt;EOF\n&lt;/ul&gt;\nEOF\n \n  echo \"按顺序追加映射文件内的文件夹完成\"\n  return 0\n\n}\n\n\n# 追加文件夹内容到 mkdocs.yml\nfunction appendPagesContent {\n  local dstDir=$1;\n  local tmpDir=$2;\n  local indent=\"$3\";\n  \n  local tmpFile;\n  local tmpRelativeFilePath;\n  local tmpBaseName;\n  local tmpBaseNameWithoutExtension;\n\n  local exitCode=0; # 返回 155 表示成功执行,且插入了内容,返回0表示成功执行\n  \n  # 先增加 index \n  tmpFile=\"${tmpDir}/index.md\"\n  if ([ -f ${tmpFile} ]);then\n    tmpRelativeFilePath=${tmpFile#${dstDir}/docs/}\n    tmpBaseName=$(basename ${tmpFile})\n    echo \"${indent}- Home: ${tmpRelativeFilePath}\" &gt;&gt; ${dstDir}/mkdocs.yml\n    # 成功插入了内容,设置exitCode\n    exitCode=155;\n  fi\n  \n  # 将文件夹下面的md文档和文件夹加入到 mkdocs.yml\n  for tmpFile in ${tmpDir}/*;do\n    tmpRelativeFilePath=${tmpFile#${dstDir}/docs/}\n    tmpBaseName=$(basename ${tmpFile})\n    tmpBaseNameWithoutExtension=${tmpBaseName%.*}\n    if ([ -f \"${tmpFile}\" ] &amp;&amp; [[ $(echo ${tmpFile} | tr 'A-Z' 'a-z') == *.md ]]);then\n        if ([ ${tmpBaseNameWithoutExtension} = index ]);then\n          continue;\n        else \n          echo \"${indent}- ${tmpBaseNameWithoutExtension}: ${tmpRelativeFilePath}\" &gt;&gt; ${dstDir}/mkdocs.yml\n      # 成功插入了内容,设置exitCode\n          exitCode=155;\n        fi\n    fi\n  \n    if ([ -d \"${tmpFile}\" ]);then\n      echo \"${indent}- ${tmpBaseNameWithoutExtension}:\" &gt;&gt; ${dstDir}/mkdocs.yml\n      appendPagesContent ${dstDir} ${tmpFile} \"${indent}  \"\n      local tmpReturnCode=$?\n      if ([ ${tmpReturnCode} -ne 155 ]);then\n    # 没有追加任何内容\n    # 删除已追加的最后一行\n    sed -i '$d' ${dstDir}/mkdocs.yml\n      else\n        # 成功插入了内容,设置exitCode\n    exitCode=155;\n      fi\n\n    fi\n  done\n  \n  # 将文件夹下面的非md文档放到一个html文件中展示\n  # 生成一个临时文件\n  tmpOtherFileMd=`mktemp`\n  \n  for tmpFile in ${tmpDir}/*;do\n    tmpRelativeFilePath=${tmpFile#${dstDir}/docs/}\n    tmpBaseName=$(basename ${tmpFile})\n    if ([ -f \"${tmpFile}\" ] \\\n       &amp;&amp; ! [[ $(echo ${tmpFile} | tr 'A-Z' 'a-z') == *.md ]] \\\n       &amp;&amp; ! [[ $(echo ${tmpFile} | tr 'A-Z' 'a-z') == *.png ]] \\\n       &amp;&amp; ! [[ $(echo ${tmpFile} | tr 'A-Z' 'a-z') == *.jpg ]] \\\n      );then\n      echo \"###### [${tmpBaseName}](./${tmpBaseName})\" &gt;&gt; ${tmpOtherFileMd}\n    fi\n  done\n  \n  if ([ -n \"$(cat ${tmpOtherFileMd})\" ]);then\n    # 将临时生成的md文件拷贝到目标文件夹\n    tmpFile=\"${tmpDir}/其他文档(自动生成).md\"\n    tmpRelativeFilePath=${tmpFile#${dstDir}/docs/}\n    tmpBaseName=$(basename ${tmpFile})\n    tmpBaseNameWithoutExtension=${tmpBaseName%.*}\n    \n    mv ${tmpOtherFileMd} \"${tmpFile}\"\n    # 将md文件添加到mkdocs\n    echo \"${indent}- ${tmpBaseNameWithoutExtension}: ${tmpRelativeFilePath}\" &gt;&gt; ${dstDir}/mkdocs.yml\n    # 成功插入了内容,设置exitCode\n    exitCode=155;\n  fi \n  \n  # 返回指定状态码\n  return ${exitCode};\n}\n\n# ================ 默认参数定义区 ================\ngitusername='globalreader'\ngitpasswd='12345qwert'\nbranch='master'\n\n# 定义使用帮助说明\nhelpMsg=\"\n所有参数不区分大小写\n--gituri docs项目git地址\n\"\n\n# ================ 处理选项 ================\nwhile [ -n \"$1\" ];do\n    tmpOpt=$(echo \"$1\"|tr A-Z a-z)\n    # 判断参数是否是 --help , 是则显示帮助并退出\n    if ([ $tmpOpt = \"--help\" ]);then\n        echo \"${helpMsg}\"\n        exit 0\n    fi\n \n    # 判断参数是否是 --bool开头,如果是则将变量置为1 并 shift 1\n    if ([[ $tmpOpt = --bool* ]]);then\n        tmpOpt=${tmpOpt#--}\n        echo \"检测到参数 ${tmpOpt}\"\n        export \"${tmpOpt}\"=\"1\"\n        shift 1\n        continue\n    fi\n \n    # 判断参数是否是 --开头,如果是则将变量置为下一个参数 并 shift 2\n    if ([[ $tmpOpt = --* ]]);then\n        tmpOpt=${tmpOpt#--}\n        echo \"检测到参数 ${tmpOpt} = $2\"\n        export \"${tmpOpt}\"=\"$2\"\n        shift 2\n        if ([ $? -ne 0 ]);then\n          shift 1\n        fi\n        continue\n    fi\n \n    shift 1\ndone\n\n# ================ 检查参数 ================\necho \"检查参数\"\n\necho \"检查gituri\"\nif ([ -z \"${gituri}\" ]);then\n   echo\n   echo \"请指定 gituri\"\n   echo \"具体帮助如下:\"\n   echo \"${helpMsg}\"\n   echo\n   exit 1\nfi\n\n# ================ 开始执行 ================\n\n# ================ git 检出代码 ================\necho \"使用git检出代码\"\n\n# 生成一个临时文件夹 用于存放 检出的代码\ntmpMkdocsDir=`mktemp -d`\ntmpGitDir=\"${tmpMkdocsDir}/docs\"\n\n# 检出代码\necho \"git clone --branch ${branch} --single-branch ${gituri} ${tmpGitDir} 1&gt;/dev/null\"\n# 把gituri加上用户名和密码\ntmpHostAndPort=$(echo \"${gituri}\" | grep -oP '(?&lt;=://)[^/]+?\\.[^/]+(?=/?)|^[^/]+?\\.[^/]+(?=/?)')\ngitrealuri=${gituri/${tmpHostAndPort}/${gitusername}:${gitpasswd}@${tmpHostAndPort}}\n\ngit clone --branch ${branch} --single-branch ${gitrealuri} ${tmpGitDir} 1&gt;/dev/null\nif ([ $? -ne 0 ]);then\n  echo\n  echo \"git clone failed!\"\n  rm -rf ${tmpMkdocsDir}\n  echo\n  exit 1\nfi\n\n# 加入 site_name 到 mkdocs.yml\ntmpBaseName=$(basename ${gituri})\nmySiteName=${tmpBaseName%.*}\n\ncat &gt; ${tmpMkdocsDir}/mkdocs.yml &lt;&lt; EOF\nsite_name: $(getMapNameForGitProjectName ${mySiteName})  \npages:\nEOF\n\n# 使用README作为index.md \nif (! [ -f ${tmpGitDir}/README.md ]);then\n  echo \"&lt;a href=\\\"../\\\"&gt;Back&lt;/a&gt;&lt;br /&gt;\" &gt; ${tmpGitDir}/index.md\nelse\n  sed -i '1i\\ &lt;a href=\\\"../\\\"&gt;Back&lt;/a&gt;&lt;br /&gt;' ${tmpGitDir}/README.md\n  mv -f ${tmpGitDir}/README.md ${tmpGitDir}/index.md\nfi\n# 生成 mkdocs.yml\nappendPagesContent ${tmpMkdocsDir} ${tmpGitDir} \"\"\n\n# 加入 theme 到 mkdocs.yml\ncat &gt;&gt; ${tmpMkdocsDir}/mkdocs.yml &lt;&lt; EOF\ntheme: windmill\nEOF\n\n# 运行 mkdocs build, 该命令会生成一个 mySiteName 目录\ncd ${tmpMkdocsDir}\necho \necho \"cat ${tmpMkdocsDir}/mkdocs.yml\"\ncat ${tmpMkdocsDir}/mkdocs.yml\necho\necho\nmkdocs build  -d ${tmpMkdocsDir}/${mySiteName}\nif ([ $? -ne 0 ]);then\n  echo\n  echo \"mkdocs build failed!\"\n  rm -rf ${tmpMkdocsDir}\n  echo\n  exit 1\nfi\n\n# 将 build 后的文件拷贝到指定位置\nnginxDir=/usr/share/nginx/html/docs\n\nrm -rf ${nginxDir}/${mySiteName}\ncp -r ${tmpMkdocsDir}/${mySiteName} ${nginxDir}/${mySiteName}\n# 生成 index.html\ncat &gt; ${nginxDir}/index.html &lt;&lt;EOF\n&lt;head&gt;\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;\n&lt;title&gt;MyDocs&lt;/title&gt;\n  &lt;style type=\"text/css\"&gt;\n    ul,li{ padding:10;margin:10;}\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;ul&gt;\nEOF\n\n# 遍历nginx根目录下的文件夹，获取其映射后的名称 加入到index.html中\n\n# 先按顺序加入文档连接\ndoAddLinkForProjectInMap \"${nginxDir}\" \"${nginxDir}/index.html\"\n\n# 继续遍历nginx根目录下加入未映射到的文件夹\n\n# 追加 ul\ncat &gt;&gt; ${nginxDir}/index.html &lt;&lt;EOF\n&lt;ul&gt;\nEOF\n\nfor file in ${nginxDir}/*;do\n  if ([ $(basename ${file}) != \"index.html\" ]);then\n    tmpMappedName=$(getMapNameForGitProjectName ${file});\n    tmpRetCode=$?\n    # 存在映射的文档之前已经加过了,所以这时只添加未映射的文档\n    # tmpRetCode = 155 表示获取到了映射名称\n    if ([ ${tmpRetCode} -ne 155 ]);then\n      echo \"&lt;li&gt;&lt;a href=\\\"./${file#${nginxDir}/}\\\" target=\\\"_blank\\\"&gt;${tmpMappedName}&lt;/a&gt;&lt;/li&gt;\" &gt;&gt; ${nginxDir}/index.html\n    fi\n  fi\ndone\n\n# 追加 /ul\ncat &gt;&gt; ${nginxDir}/index.html &lt;&lt;EOF\n&lt;/ul&gt;\nEOF\n\n# 追加 /body\ncat &gt;&gt; ${nginxDir}/index.html &lt;&lt;EOF\n&lt;/body&gt;\nEOF\n\n# 结束后删除文件\nrm -rf ${tmpMkdocsDir}\n\necho \"成功使用mkdocs部署文档项目${gituri}\"\necho\n</code></pre>\n<h2>中文搜索问题</h2>\n<pre><code class=\"language-python\"># 安装分词工具\npip install jieba\n\n# 修改 /usr/lib/python2.7/site-packages/mkdocs/contrib/legacy_search/search_index.py\n    def generate_search_index(self):\n        \"\"\"python to json conversion\"\"\"\n        page_dicts = {\n            'docs': self._entries,\n        }\n        # 以下为新增部分\n        for doc in page_dicts['docs']:\n        # 调用jieba的cut接口生成分词库，过滤重复词，过滤空格\n            tokens = list(set([token.lower() for token in jieba.cut_for_search(doc['title'].replace('\\n', ''), True)]))\n            if '' in tokens:\n                tokens.remove('')\n            doc['title_tokens'] = tokens\n\n            tokens = list(set([token.lower() for token in jieba.cut_for_search(doc['text'].replace('\\n', ''), True)]))\n            if '' in tokens:\n                tokens.remove('')\n            doc['text_tokens'] = tokens\n\n        # 新增部分结束\n        return json.dumps(page_dicts, sort_keys=True, indent=4)\n\n# 修改 /usr/lib/python2.7/site-packages/mkdocs/contrib/legacy_search/templates/search/lunr.min.js\n# 这个是压缩过的, 是不是可以下载一个未压缩版的, 应该更好修改\n# 有两个地方要修改：\n# lunr.Index.prototype.add: 获取分词数据的方式，不在从内部的分词接口计算分词，直接从文档的词库加载\n# lunr.trimmer: 过滤空白字符的接口，修改匹配方式，把原来只匹配字母、数字改成匹配所有非空字符\n\nlunr.Index.prototype.add = function (doc, emitEvent) {\n  var docTokens = {},\n      allDocumentTokens = new lunr.SortedSet,\n      docRef = doc[this._ref],\n      emitEvent = emitEvent === undefined ? true : emitEvent\n\n  this._fields.forEach(function (field) {\n    // 删掉内部接口计算分词\n    // var fieldTokens = this.pipeline.run(this.tokenizerFn(doc[field.name]))\n    // 直接从文档词库加载\n    var fieldTokens = doc[field.name + '_tokens']\n\n    docTokens[field.name] = fieldTokens\n\n    for (var i = 0; i &lt; fieldTokens.length; i++) {\n      var token = fieldTokens[i]\n      allDocumentTokens.add(token)\n      this.corpusTokens.add(token)\n    }\n  }, this)\n\n\nlunr.trimmer = function (token) {\n  var result = token.replace(/^\\s+/, '').replace(/\\s+$/, '')  //  \\W -&gt; \\s\n  return result === '' ? undefined : result\n}\n\n</code></pre>\n<p>参考 基于mkdocs-material搭建个人静态博客(含支持的markdown语法)</p>\n<p><a href=\"https://cyent.github.io/markdown-with-mkdocs-material/\">点击阅读</a></p>\n",
  "link": "\\en-us\\blog\\tool\\mkdocs.html",
  "meta": {}
}