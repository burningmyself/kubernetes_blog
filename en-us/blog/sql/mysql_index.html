<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="mysql_index" />
	<meta name="description" content="mysql_index" />
	<!-- 网页标签标题 -->
	<title>mysql_index</title>
	<link rel="shortcut icon" href="/img/docsite.ico"/>
	<link rel="stylesheet" href="/build/blogDetail.css" />
</head>
<body>
	<div id="root"><div class="blog-detail-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/en-us/index.html"><img class="logo" src="/img/dubbo_colorful.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">中</span><div class="header-menu"><img class="header-menu-toggle" src="/img/system/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/en-us/index.html" target="_self">HOME</a></li><li class="menu-item menu-item-normal"><a href="/en-us/docs/introduction.html" target="_self">DOCS</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/en-us/blog/index.html" target="_self">BLOG</a></li><li class="menu-item menu-item-normal"><a href="/en-us/community/index.html" target="_self">COMMUNITY</a></li></ul></div></div></header><section class="blog-content markdown-body"><h1>MySQL索引优化</h1>
<hr>
<p>本文主要讨论MySQL索引的部分知识。将会从MySQL索引基础、索引优化实战和数据库索引背后的数据结构三部分相关内容，下面一一展开。</p>
<h2>一、MySQL——索引基础</h2>
<p>首先，我们将从索引基础开始介绍一下什么是索引，分析索引的几种类型，并探讨一下如何创建索引以及索引设计的基本原则。</p>
<p>此部分用于测试索引创建的pay_user表的结构如下：</p>
<p><img src="./../img/mysql-index-1.png" alt="index"></p>
<h3>1、什么是索引</h3>
<p>“索引（在MySQL中也叫“键key”）是存储引擎快速找到记录的一种数据结构。”
——《高性能MySQL》</p>
<p>我们需要知道索引其实是一种数据结构，其功能是帮助我们快速匹配查找到需要的数据行，是数据库性能优化最常用的工具之一。其作用相当于超市里的导购员、书本里的目录。</p>
<h3>2、索引类型</h3>
<p>可以使用SHOW INDEX FROM table_name;查看索引详情：</p>
<p><img src="./../img/mysql-index-2.png" alt="index"></p>
<ul>
<li>主键索引 PRIMARY KEY</li>
</ul>
<p>它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引。注意：一个表只能有一个主键。</p>
<ul>
<li>唯一索引 UNIQUE</li>
</ul>
<p>唯一索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</p>
<p>可以通过ALTER TABLE table_name ADD UNIQUE [alias] (column);创建唯一索引：</p>
<p><img src="./../img/mysql-index-3.png" alt="index"></p>
<p>可以通过ALTER TABLE table_name ADD UNIQUE [alias] (column1,column2);创建唯一组合索引：</p>
<p><img src="./../img/mysql-index-4.png" alt="index"></p>
<ul>
<li>普通索引 INDEX</li>
</ul>
<p>这是最基本的索引，它没有任何限制。</p>
<p>可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引：</p>
<p><img src="./../img/mysql-index-5.png" alt="index"></p>
<ul>
<li>组合索引 INDEX
即一个索引包含多个列，多用于避免回表查询。</li>
</ul>
<p>可以通过ALTER TABLE table_name ADD INDEX index_name(column1,column2, column3);创建组合索引：</p>
<p><img src="./../img/mysql-index-6.png" alt="index"></p>
<p>全文索引 FULLTEXT</p>
<p>也称全文检索，是目前搜索引擎使用的一种关键技术。</p>
<p>可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引：</p>
<p><img src="./../img/mysql-index-7.png" alt="index"></p>
<p>索引一经创建不能修改，如果要修改索引，只能删除重建。可以使用DROP INDEX index_name ON table_name;删除索引。</p>
<h3>3、索引设计的原则</h3>
<ol>
<li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列；</li>
<li>基数较小的类，索引效果较差，没有必要在此列建立索引；</li>
<li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间；</li>
<li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li>
</ol>
<h2>二、MySQL——索引优化实战</h2>
<p>上面我们介绍了索引的基本内容，这部分我们介绍索引优化实战。在介绍索引优化实战之前，首先要介绍两个与索引相关的重要概念，这两个概念对于索引优化至关重要。</p>
<p>此部分用于测试的user表结构：</p>
<p><img src="./../img/mysql-index-8.png" alt="index"></p>
<h3>1、索引相关的重要概念</h3>
<ul>
<li>基数
单个列唯一键（distict_keys）的数量叫做基数。</li>
</ul>
<p>SELECT COUNT(DISTINCT UserName),COUNT(DISTINCT LoginPassWord) FROM pay_user;</p>
<p><img src="./../img/mysql-index-9.png" alt="index"></p>
<p>pay_user表的总行数是5，UserName列的基数是10，说明LoginPassWord列里面有大量重复值，UserName列的基数等于总行数，说明UserName列没有重复值，相当于主键。</p>
<p>返回数据的比例：
pay_user表中共有5条数据：
<img src="./../img/mysql-index-11.png" alt="index"></p>
<p>基数越大命中索引命中越高，一半取表数据30%一下走索引</p>
<ul>
<li>回表</li>
</ul>
<p>当对一个列创建索引之后，索引会包含该列的键值及键值对应行所在的rowid。通过索引中记录的rowid访问表中的数据就叫回表。回表次数太多会严重影响SQL性能，如果回表次数太多，就不应该走索引扫描，应该直接走全表扫描。</p>
<p>EXPLAIN命令结果中的Using Index意味着不会回表，通过索引就可以获得主要的数据。Using Where则意味着需要回表取数据。</p>
<h3>2、索引优化实战</h3>
<p>有些时候虽然数据库有索引，但是并不被优化器选择使用。</p>
<p>我们可以通过SHOW STATUS LIKE 'Handler_read%';查看索引的使用情况：</p>
<p><img src="./../img/mysql-index-12.png" alt="index"></p>
<ul>
<li>Handler_read_key：如果索引正在工作，Handler_read_key的值将很高。</li>
<li>Handler_read_rnd_next：数据文件中读取下一行的请求数，如果正在进行大量的表扫描，值将较高，则说明索引利用不理想。</li>
</ul>
<h4>索引优化规则：</h4>
<ul>
<li>如果MySQL估计使用索引比全表扫描还慢，则不会使用索引。</li>
</ul>
<p>返回数据的比例是重要的指标，比例越低越容易命中索引。记住这个范围值——30%，后面所讲的内容都是建立在返回数据的比例在30%以内的基础上。</p>
<ul>
<li>前导模糊查询不能命中索引。</li>
</ul>
<p>UserName列创建普通索引：</p>
<p>前导模糊查询不能命中索引：</p>
<p>EXPLAIN SELECT * FROM pay_user WHERE UserName LIKE '%s%';</p>
<p>非前导模糊查询则可以使用索引，可优化为使用非前导模糊查询：</p>
<p>EXPLAIN SELECT * FROM pay_user WHERE UserName LIKE 's%';</p>
<ul>
<li>数据类型出现隐式转换的时候不会命中索引，特别是当列类型是字符串，一定要将字符常量值用引号引起来。
EXPLAIN SELECT * FROM pay_user WHERE UserName=1;--未使用索引</li>
</ul>
<p>EXPLAIN SELECT * FROM user WHERE name='1';--使用索引</p>
<ul>
<li>复合索引的情况下，查询条件不包含索引列最左边部分（不满足最左原则），不会命中符合索引。</li>
</ul>
<p>注意，最左原则并不是说是查询条件的顺序</p>
<ul>
<li>union、in、or都能够命中索引，建议使用in。</li>
</ul>
<p>查询的CPU消耗：or&gt;in&gt;union</p>
<ul>
<li>用or分割开的条件，如果or前的条件中列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到。</li>
</ul>
<p>因为or后面的条件列中没有索引，那么后面的查询肯定要走全表扫描，在存在全表扫描的情况下，就没有必要多一次索引扫描增加IO访问。</p>
<ul>
<li>
<p>负向条件查询不能使用索引，可以优化为in查询。
负向条件有：!=、&lt;&gt;、not in、not exists、not like等。</p>
</li>
<li>
<p>范围条件查询可以命中索引。范围条件有：&lt;、&lt;=、&gt;、&gt;=、between等。</p>
</li>
</ul>
<p>范围列可以用到索引（联合索引必须是最左前缀），但是范围列后面的列无法用到索引，索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引：</p>
<p>如果是范围查询和等值查询同时存在，优先匹配等值查询列的索引：</p>
<ul>
<li>数据库执行计算不会命中索引</li>
</ul>
<p>计算逻辑应该尽量放到业务层处理，节省数据库的CPU的同时最大限度的命中索引。</p>
<ul>
<li>利用覆盖索引进行查询，避免回表。</li>
</ul>
<p>被查询的列，数据能从索引中取得，而不用通过行定位符row-locator再到row上获取，即“被查询列要被所建的索引覆盖”，这能够加速查询速度。</p>
<p>当查询其他列时，就需要回表查询，这也是为什么要避免SELECT*的原因之一：</p>
<ul>
<li>建立索引的列，不允许为null。</li>
</ul>
<p>单列索引不存null值，复合索引不存全为null的值，如果列允许为null，可能会得到“不符合预期”的结果集，所以，请使用not null约束以及默认值。</p>
<p>虽然IS NULL可以命中索引，但是NULL本身就不是一种好的数据库设计，应该使用NOT NULL约束以及默认值。</p>
<ul>
<li>更新十分频繁的字段上不宜建立索引：因为更新操作会变更B+树，重建索引。这个过程是十分消耗数据库性能的。</li>
<li>区分度不大的字段上不宜建立索引：类似于性别这种区分度不大的字段，建立索引的意义不大。因为不能有效过滤数据，性能和全表扫描相当。另外返回数据的比例在30%以外的情况下，优化器不会选择使用索引。</li>
<li>业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。虽然唯一索引会影响insert速度，但是对于查询的速度提升是非常明显的。另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，在并发的情况下，依然有脏数据产生。</li>
<li>多表关联时，要保证关联字段上一定有索引。</li>
<li>创建索引时避免以下错误观念：索引越多越好，认为一个查询就需要建一个索引；宁缺勿滥，认为索引会消耗空间、严重拖慢更新和新增速度；抵制唯一索引，认为业务的唯一性一律需要在应用层通过“先查后插”方式解决；过早优化，在不了解系统的情况下就开始优化。</li>
</ul>
<h3>3、总结</h3>
<p>对于自己编写的SQL查询语句，要尽量使用EXPLAIN命令分析一下，做一个对SQL性能有追求的程序员。衡量一个程序员是否靠谱，SQL能力是一个重要的指标。作为后端程序员，深以为然。</p>
<h2>三、数据库索引背后的数据结构</h2>
<p>第一部分开头我们简单提到，索引是存储引擎快速找到记录的一种数据结构。进一步说，在数据库系统里，这种数据结构要满足特定查找算法，即这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。</p>
<p><img src="./../img/mysql-index-13.png" alt="index"></p>
<h3>1、B-Tree</h3>
<p>B-Tree是一种平衡的多路查找(又称排序)树，在文件系统中和数据库系统中有所应用，主要用作文件的索引。其中的B就表示平衡(Balance) 。</p>
<p><img src="./../img/mysql-index-14.png" alt="index"></p>
<h3>B-Tree的特性</h3>
<p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：</p>
<p>d为大于1的一个正整数，称为B-Tree的度：</p>
<p><img src="./../img/mysql-index-15.png" alt="index"></p>
<p>h为一个正整数，称为B-Tree的高度：</p>
<p><img src="./../img/mysql-index-16.png" alt="index"></p>
<p>key和指针互相间隔，节点两端是指针：</p>
<p><img src="./../img/mysql-index-17.png" alt="index"></p>
<p>一个节点中的key从左到右非递减排列：</p>
<p><img src="./../img/mysql-index-18.png" alt="index"></p>
<p>所有节点组成树结构。</p>
<p>每个指针要么为null，要么指向另外一个节点；每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d：</p>
<p>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null：</p>
<p>所有叶节点具有相同的深度，等于树高h。</p>
<p>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于key1，其中key1为node的第一个key的值：</p>
<p>如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于keym，其中keym为node的最后一个key的值：</p>
<p>如果某个指针在节点node的左右相邻key分别是keyi和keyi+1且不为null，则其指向节点的所有key小于keyi+1且大于keyi：</p>
<h3>B-Tree查找数据</h3>
<p>B-Tree是一个非常有效率的索引数据结构。这主要得益于B-Tree的度可以非常大，高度会变的非常小，只需要二分几次就可以找到数据。例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2))，检索一个key，其查找节点个数的渐进复杂度为O(logdN)。</p>
<p>在B-Tree中按key检索数据的算法非常直观：</p>
<ul>
<li>首先从根节点进行二分查找，如果找到则返回对应节点的data；</li>
<li>否则对相应区间的指针指向的节点递归进行查找，如果找到则返回对应节点的data；</li>
<li>如果找不到，则重复上述“对相应区间的指针指向的节点递归进行查找”，直到找到节点或找到null指针，前者查找成功，后者查找失败。</li>
</ul>
<h3>2、B+Tree</h3>
<p>B+Tree是B-Tree的一种变种。一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在以后讨论。</p>
<p>B+Tree的特性:</p>
<p>区别于B-Tree:</p>
<p>每个节点的指针上限为2d而不是2d+1；
内节点不存储data，只存储key；叶子节点不存储指针。</p>
<p>3、带有顺序访问指针的B+Tree</p>
<p>一般在数据库系统或者文件系统中，并不是直接使用B+Tree作为索引数据结构的，而是在B+Tree的基础上做了优化，增加了顺序访问指针，提升了区间查询的性能。</p>
<p>如上图所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。</p>
<p>例如要查询18到30之间的数据记录，只要先找到18，然后顺着顺序访问指针就可以访问到所有的数据节点。这样就提升了区间查询的性能。数据库的索引全扫描index和索引范围扫描range就是基于此实现的。</p>
</section><footer class="footer-container"><div class="footer-body"><img src="/img/dubbo_gray.png"/><div class="cols-container"><div class="col col-12"><h3>Disclaimer</h3><p>the disclaimer content</p></div><div class="col col-6"><dl><dt>Documentation</dt><dd><a href="/en-us/docs/introduction.html" target="_self">Overview</a></dd><dd><a href="/en-us/docs/introduction.html" target="_self">Quick start</a></dd><dd><a href="/en-us/docs/dir/introduction.html" target="_self">Developer guide</a></dd></dl></div><div class="col col-6"><dl><dt>Resources</dt><dd><a href="/en-us/blog/index.html" target="_self">Blog</a></dd><dd><a href="/en-us/community/index.html" target="_self">Community</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2018 BurningMyself</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/blogDetail.js"></script>
</body>
</html>