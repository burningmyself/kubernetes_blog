{
  "filename": "c_core_safety.md",
  "__html": "<h1><a href=\"http://xn--ASP-x69di30p5r0a.NET\">让你的ASP.NET</a> Core应用程序更安全</h1>\n<p><a href=\"http://xn--ASP-xi9dk72d.NET\">对于ASP.NET</a> Core应用程序，除了提供认证和授权机制来保证服务的安全性，还需要考虑下面的一些安全因素：</p>\n<ul>\n<li>\n<p>CSRF</p>\n</li>\n<li>\n<p>强制HTTPS</p>\n</li>\n<li>\n<p>安全的HTTP Headers</p>\n</li>\n</ul>\n<h3>CSRF</h3>\n<p><a href=\"http://ASP.NET\">ASP.NET</a> Core通过AntiForgeryToken来阻止CSRF攻击，一般来说，当用户做表单提交的时候，表单中隐藏的token也会被提交到服务端，与此同时cookie中包含的另一半token也被提交到服务端，服务端通过合并两份token来验证客户端的数据是否有效。</p>\n<p><a href=\"http://xn--ASP-uc0e316agqd.NET\">例如在ASP.NET</a> Core中通过下面的方式渲染表单:</p>\n<pre><code class=\"language-c#\">&lt;form asp-controller=<span class=\"hljs-string\">\"Manage\"</span> asp-action=<span class=\"hljs-string\">\"ChangePassword\"</span> method=<span class=\"hljs-string\">\"post\"</span>&gt;\n   &lt;!-- Form details --&gt;\n&lt;/form&gt;\n</code></pre>\n<p>这样会生成下面的html，表单会包含一个隐藏的token</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"post\"</span> <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">\"/Manage/ChangePassword\"</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- Form details --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"__RequestVerificationToken\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"hidden\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"CfDJ8NrAkSldwD9CpLR...LongValueHere!\"</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n</code></pre>\n<p>服务端的代码通过在对应的action上标记ValidateAntiForgeryToken来验证客户端的请求</p>\n<pre><code class=\"language-C#\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ManageController</span>\n{\n  [<span class=\"hljs-meta\">HttpPost</span>]\n  [<span class=\"hljs-meta\">ValidateAntiForgeryToken</span>]\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> IActionResult <span class=\"hljs-title\">ChangePassword</span>(<span class=\"hljs-params\"></span>)</span>\n  {\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-keyword\">return</span> View();\n  }\n}\n</code></pre>\n<p>是不是每个POST请求都需要添加这样的attribute呢？</p>\n<p><a href=\"http://ASP.NET\">ASP.NET</a> Core中有Filter的概念，通过添加全局Filter就能帮我们达到这样的目的：</p>\n<pre><code class=\"language-C#\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Startup</span>\n{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ConfigureServices</span>(<span class=\"hljs-params\">IServiceCollection services</span>)</span>\n  {\n    services.AddMvc(options =&gt;\n    {\n        options.Filters.Add(<span class=\"hljs-keyword\">new</span> AutoValidateAntiforgeryTokenAttribute());\n    });\n  }\n}\n</code></pre>\n<p>AutoValidateAntiforgeryTokenAttribute会自动忽略不需要做CSRF验证的请求类型，例如HttpGet请求。</p>\n<h3>强制HTTPS</h3>\n<p>为了让服务更加安全，你还可以强制用户使用https，你可以通过配置API网关的方式达到这个目的，<a href=\"http://xn--ASP-kd9d0x22af1uc15e.NET\">也可以使用ASP.NET</a> Core自带的特性。</p>\n<p>使用了RequireHttpsAttribute之后，http请求将会报错。</p>\n<pre><code class=\"language-C#\">services.Configure&lt;MvcOptions&gt;(options =&gt;\n{\n     options.Filters.Add(<span class=\"hljs-keyword\">new</span> RequireHttpsAttribute());\n});\n</code></pre>\n<p>通过下面的方式强行跳转到https。</p>\n<pre><code class=\"language-C#\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Configure</span>(<span class=\"hljs-params\">IApplicationBuilder app, IHostingEnvironment env</span>)</span>\n{\n    app.UseHttpsRedirection();\n}\n</code></pre>\n<h3>让HTTP Header更加安全</h3>\n<p>通过https://securityheaders.com/来检查HTTP Header是不是安全，例如下面的扫描结果：\n<img src=\"./../img/c_core_safety1.png\" alt=\"safety\"></p>\n<p><a href=\"http://xn--NWebsecASP-wf2pyp08u93dze956n720brteqq3f9xftrc.NET\">NWebsec是一个用来做安全相关的ASP.NET</a> Core类库，<a href=\"http://xn--ASP-iq0fk01w.NET\">针对ASP.NET</a> Core中HTTP Header相关的修复，可以添加下面的Nuget包：</p>\n<p>NWebsec.AspNetCore.Middleware</p>\n<ul>\n<li>Strict-Transport-Security：为了告诉浏览器所有的资源都必须使用https，你需要添加这个header:</li>\n</ul>\n<pre><code class=\"language-C#\">app.UseHsts(hsts =&gt; hsts.MaxAge(<span class=\"hljs-number\">365</span>));\n</code></pre>\n<ul>\n<li>Redirect validation: 一旦启用了这个中间件，只能被Redirect到允许的站点, 否则会触发RedirectValidationException</li>\n</ul>\n<pre><code class=\"language-C#\">app.UseRedirectValidation(opts =&gt;\n{\n    opts.AllowSameHostRedirectsToHttps();       opts.AllowedDestinations(<span class=\"hljs-string\">\"https://www.google.com/accounts/\"</span>);\n});\n</code></pre>\n<ul>\n<li>Referrer-Policy: 当用户点击了浏览器上的连接，请求报头中Referrer用来表示连接的来源，这个特性也可以用来做一些数据分析，通过Referrer-Policy可以控制是否显示Referrer:</li>\n</ul>\n<pre><code class=\"language-C#\">app.UseReferrerPolicy(opts =&gt; opts.NoReferrer());\n</code></pre>\n<ul>\n<li>Content-Security-Policy:内容安全策略，这个http header可以让浏览器自动禁止外部注入恶意脚本，例如下面的策略将限制所有的脚本只能从同域加载：</li>\n</ul>\n<pre><code class=\"language-C#\"><span class=\"hljs-string\">'Content-Security-Policy'</span>: <span class=\"hljs-string\">'script-src \\'self\\''</span>\n</code></pre>\n<ul>\n<li>下面的脚本引用将会引起浏览器报错：</li>\n</ul>\n<pre><code class=\"language-js\">&lt;script type=<span class=\"hljs-string\">\"text/javascript\"</span> \nsrc=<span class=\"hljs-string\">\"https://cdn.bootcss.com/jquery/3.3.1/jquery.js\"</span>&gt;<span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre>\n<ul>\n<li>使用NWebsec配置Content-Security-Policy:</li>\n</ul>\n<pre><code class=\"language-C#\">app.UseCsp(options =&gt; options\n        .DefaultSources(s =&gt; s.Self())\n        .ScriptSources(s =&gt; s.Self().CustomSources(<span class=\"hljs-string\">\"scripts.nwebsec.com\"</span>))\n        .ReportUris(r =&gt; r.Uris(<span class=\"hljs-string\">\"/report\"</span>)));\n</code></pre>\n<ul>\n<li>X-XSS-Protection: 防XSS攻击设置</li>\n</ul>\n<pre><code class=\"language-C#\">app.UseXXssProtection(options =&gt; options.EnabledWithBlockMode());\n</code></pre>\n<ul>\n<li>X-Content-Type-Options: 如果服务器发送响应头 X-Content-Type-Options: nosniff，则 script 和 styleSheet 元素会拒绝包含错误的 MIME 类型的响应。这是一种安全功能，有助于防止基于 MIME 类型混淆的攻击。</li>\n</ul>\n<pre><code class=\"language-C#\">app.UseXContentTypeOptions();\n</code></pre>\n",
  "link": "\\en-us\\blog\\net\\c_core_safety.html",
  "meta": {}
}